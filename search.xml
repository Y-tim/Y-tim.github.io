<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>父目录</category>
        <category>子目录一</category>
        <category>子目录二</category>
      </categories>
      <tags>
        <tag>标签一</tag>
        <tag>标签二</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github博客搭建</title>
    <url>/2021/12/11/hexo+github%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="hexo-github个人博客搭建"><a href="#hexo-github个人博客搭建" class="headerlink" title="hexo+github个人博客搭建"></a>hexo+github个人博客搭建</h1><h2 id="一、需要用到的网站"><a href="#一、需要用到的网站" class="headerlink" title="一、需要用到的网站"></a>一、需要用到的网站</h2><p>Git <a href="https://git-scm.com/downloads">官网</a></p>
<p>Hexo <a href="https://hexo.io/zh-cn/">官网</a></p>
<p>Node.js <a href="https://nodejs.org/zh-cn/">官网</a></p>
<p>GIthub <a href="https://github.com/">官网</a></p>
<h2 id="二、环境安装教程"><a href="#二、环境安装教程" class="headerlink" title="二、环境安装教程"></a>二、环境安装教程</h2><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">进入官网选择自己的电脑系统下载，默认安装即可</span><br></pre></td></tr></table></figure>

<p>Git安装完成验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、配置自己的环境变量，将bin目录添加到电脑的path环境中</span><br><span class="line">2、然后win + r 进入cmd</span><br><span class="line">3、输入git version</span><br><span class="line">==</span><br><span class="line">出现git版本号就代表安装成功</span><br></pre></td></tr></table></figure>



<h3 id="Nodes-js安装"><a href="#Nodes-js安装" class="headerlink" title="Nodes.js安装"></a>Nodes.js安装</h3><p><img src="https://s2.loli.net/2021/12/10/EXf81gkwGjUPoty.png" alt="image-20211210093940263"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、根据自己的电脑系统及位数选择安装格式</span><br><span class="line">==</span><br><span class="line">	.msi是windows installer开发出来的程序安装文件，也就是把所有相关文件封装在一个包里。</span><br><span class="line">	.zip是一个压缩包，解压即可，无需安装</span><br><span class="line">==</span><br><span class="line">2、我选择的是.msi格式的文件，默认一直下一步，过程中可以自定义安装路径，默认安装位置在c盘的program files下。</span><br><span class="line">3、选择.msi格式安装的话会默认添加环境变量，在cmd中输入node -v查看版本，如果有版本显示说明安装成功，没有的话手动添加环境变量到path。</span><br><span class="line">4、新版的node也会安装npm，在cmd中输入npm -v查看版本。</span><br><span class="line">5、以上过程都能正常显示，说明node.js安装成功</span><br></pre></td></tr></table></figure>

<p>安装完成的目录</p>
<p><img src="https://s2.loli.net/2021/12/10/fZhcpSeUKTBvtVQ.png" alt="image-20211210094622770"></p>
<h2 id="三、博客系统安装"><a href="#三、博客系统安装" class="headerlink" title="三、博客系统安装"></a>三、博客系统安装</h2><p>1、选择一个盘符，我选择的是E盘，然后创建一个文件夹，名字自己定义，我的是E：\blog，然后进入blog文件夹，右键选择Git Bash Here</p>
<p><img src="https://s2.loli.net/2021/12/10/brU3CDsEhWei5jg.png" alt="image-20211210095918382"></p>
<p>2、根据hexo官网首页的命令安装hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>3、安装完成之后，输入命令查看版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2021/12/10/UXHt3KdgPTRkVu6.png" alt="image-20211210100353870"></p>
<p>4、输入hexo init 等待初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2021/12/10/ZHtwr8EuIxVS4qj.png" alt="image-20211210100514812"></p>
<p><img src="https://s2.loli.net/2021/12/10/1Qs25NfRbMxSkLC.png" alt="image-20211210100536305"></p>
<p>5、然后输入命令hexo generate或者缩写hexo g生成html页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2021/12/10/EigSv1PbHI3nkBG.png" alt="image-20211210100821970"></p>
<ul>
<li>然后就会出现一个新的文件public，里面包含了hexo生成的html，css，json之类的东西</li>
</ul>
<p><img src="https://s2.loli.net/2021/12/10/KNFWsv2EpCeLHSj.png" alt="image-20211210100947245"></p>
<p>6、使用命令hexo server 和缩写成hexo s启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2021/12/10/b1MkjRucWZLGJKa.png" alt="image-20211210101050232"></p>
<p>7、以上就是按照默认的方式生成好了个人博客，根据上面的地址访问</p>
<p><img src="https://s2.loli.net/2021/12/10/fz5nqeok3il98K4.png" alt="image-20211210101210965"></p>
<h2 id="四、安装其他主题"><a href="#四、安装其他主题" class="headerlink" title="四、安装其他主题"></a>四、安装其他主题</h2><ul>
<li>我是根据大佬的安装方式实现主题的切换。在此感谢大佬！！！<a href="https://shen-yu.gitee.io/2019/ayer/">点击这里</a>进入安装说明（<strong>我采用的是第二种方式，直接git clone主题所在的网址即可，这样我更方便管理我的主题内容和更换自己的布局</strong>）</li>
</ul>
<h2 id="五、文章创作测试"><a href="#五、文章创作测试" class="headerlink" title="五、文章创作测试"></a>五、文章创作测试</h2><p><img src="https://s2.loli.net/2021/12/10/pl7HfEyu8S6QgqL.png" alt="image-20211210102705051"></p>
<p>1、以上为侧边栏内容，该内容对应的是个人博客目录的source中的内容，以下是我直接克隆下来的东西，切换主题只需要将blog目录下的_config.yml文件中的Themes下的主题名字修改成我们的目标主题，这里我的主题是ayer，目录对应在下面的source中。</p>
<p><img src="https://s2.loli.net/2021/12/11/mVDnrHXUIKgPd2f.png" alt="image-20211211171115622"></p>
<p><img src="https://s2.loli.net/2021/12/10/WenQZGm9c6ExJX5.png" alt="image-20211210103056519"></p>
<p>2、以上目录中的__posts是安装主题之后就已经存在的，下面的分类，标签，后面可能还有别的，都是在git命令行执行命令产生的，然后在生成的文件夹下面创建index.md文件，按照下图配置，完成之后就不用管了</p>
<p><img src="https://s2.loli.net/2021/12/10/x43yiWYORzhnobP.png" alt="image-20211210103447077"></p>
<p>3、回到source目录中，进入_posts目录中开始创作文章</p>
<ul>
<li>创建XXX.md文件，第一步顶部编辑模板内容==要想在侧边栏查看除了主页和归档的内容外，必须要先配置侧边栏的内容==</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello</span><br><span class="line">categories: &quot;归档测试&quot;</span><br><span class="line">tags: &quot;标签测试&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<ul>
<li>title：侧边栏归档中显示的名称</li>
<li>categories：侧边栏分类中显示的名称</li>
<li>tags：侧边栏标签中显示的名称</li>
</ul>
<p><img src="https://s2.loli.net/2021/12/10/ku19YJR3fWQxvcd.png" alt="image-20211210104637132"></p>
<p><img src="https://s2.loli.net/2021/12/10/8CDvygtwjpJ1nim.png" alt="image-20211210105146894"></p>
<p>4、完成以上操作之后,在根目录中进入git界面，输入命令开始部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean </span><br><span class="line">$ hexo g </span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>



<h2 id="六、个人博客部署到Github"><a href="#六、个人博客部署到Github" class="headerlink" title="六、个人博客部署到Github"></a>六、个人博客部署到Github</h2><p>1、登录到Github中新建一个仓库，仓库名称必须为==Github用户名==.github.io</p>
<p><strong>例如</strong></p>
<p>我的用户名是：Y-tim</p>
<p>那么我的仓库名字为：Y-tim.github.io</p>
<p>==点击创建，其他就不用管了==</p>
<p><img src="https://s2.loli.net/2021/12/10/UBipgOjZenGdwHW.png" alt="image-20211210110518004"></p>
<p>2、回到自己的Git控制台中，配置Github账户信息，（其中==用户名==和==邮箱==都替换成你自己的注测Github的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;用户名&quot;</span><br><span class="line">$ git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>



<p>3、生成ssh公钥和秘钥(==为了部署的时候不需要每次都输入账号密码==)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;你的Github邮箱&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行完毕之后，生成的秘钥在c盘中的用户里面，有一个.ssh目录，将里面的<code>id_rsa.pub</code>文件内容复制</li>
<li>进入到你创建好的仓库中，点击setting–》Deploy Key—》Add new，完成粘贴并保存。</li>
</ul>
<p><img src="https://s2.loli.net/2021/12/10/XOe6utqS5yl9zYb.png" alt="image-20211210111424186"></p>
<p>4、再回到blog根目录下面，在==_config.yml==文件里面搜索deploy所在的位置，一般在最底部，添加配置条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repo: git@github.com:Y-tim/Y-tim.github.io.git</span><br><span class="line"> branch: main</span><br></pre></td></tr></table></figure>

<ul>
<li>==因为是yml文件，所以格式很敏感，type后面有空格，其他也一样==</li>
<li>type： git –》因为是github所以这里是git</li>
<li>repo：就是平时克隆项目的位置，随便复制一个地址都可以</li>
<li>branch： 这是上传到项目中的分支，==分支最好是该项目的默认分支，main或者master都可以== </li>
</ul>
<p><img src="https://s2.loli.net/2021/12/10/28HhbEwAOKkZoMV.png" alt="image-20211210111843817"></p>
<p><img src="https://s2.loli.net/2021/12/10/xr1hbpcMjZI8To4.png" alt="image-20211210112609385"></p>
<p>5、回到git控制台，安装一键部署工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>6、然后执行以下命令完成最终部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean                            #清除缓存       可缩写hexo c</span><br><span class="line">$ hexo generate                         #生成静态文件    可缩写hexo g</span><br><span class="line">$ hexo deploy                           #部署到Github   可缩写hexo d</span><br></pre></td></tr></table></figure>

<p>==可以使用脚本进行一键双击部署以及更新==</p>
<p>编写==自定义名称.sh== 的脚本：保存在方便点击的地方，当编辑完文章保存之后，直接双击该脚本就行，它会自动完成部署</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deploy_hexo.sh</span></span><br><span class="line"><span class="built_in">cd</span> /e/logan_test/blog</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment"># 白底黑字效果</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo clean&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo g&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo d&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span></span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Successful！！！&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span></span><br><span class="line">sleep 5</span><br><span class="line"><span class="comment"># 执行完毕不退出</span></span><br><span class="line"><span class="comment"># exec /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>==点击运行的效果==</p>
<p><img src="https://s2.loli.net/2021/12/10/cuDS9IUQTegkaxB.png" alt="image-20211210235820463"></p>
<p>7、项目部署到github之后，回到Github中，点击setting—》pages，选择分支，根目录，点击save</p>
<p><img src="https://s2.loli.net/2021/12/10/ML8FYia1NJwcEDg.png" alt="image-20211210113113809"></p>
<p>8、访问 <a href="https://y-tim.github.io/">https://y-tim.github.io/</a></p>
<p><img src="https://s2.loli.net/2021/12/10/86dZP7TCfmunXob.png" alt="image-20211210113255351"></p>
<p>==剩下的界面优化，只需要在该主题的配置文件中修改即可==</p>
<p><strong>主题配置文件在你克隆下来的根目录下</strong>：==__config.yml==</p>
<h2 id="七、Github绑定域名"><a href="#七、Github绑定域名" class="headerlink" title="七、Github绑定域名"></a>七、Github绑定域名</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>​    将自己购买的域名，通过实名认证和解析dns之后即可实现使用域名访问我们在Github上面部署的个人博客。</p>
<h3 id="绑定步骤："><a href="#绑定步骤：" class="headerlink" title="绑定步骤："></a>绑定步骤：</h3><p>1、在域名服务当中你可以看到自己购买的域名，购买完成之后是需要实名的，根据向导一步一步操作即可。</p>
<p><img src="https://s2.loli.net/2021/12/10/Nv1dpFjYBxay4IU.png" alt="image-20211210233141000"></p>
<p>2、在域名的后面有一个解析，点击解析进入到域名解析界面</p>
<p><img src="https://s2.loli.net/2021/12/10/zl61VeUydskJRr9.png" alt="image-20211210233225710"></p>
<p><img src="https://s2.loli.net/2021/12/10/7xvD1pqMdburKEV.png" alt="image-20211210233318982"></p>
<p>3、点击添加记录，然后配置域名指向，主机记录（这个意思是输入url的时候前面加上www.）,解析路线默认，记录值为你GIthub博客地址，我的是y-tim.github.io.</p>
<p><img src="https://s2.loli.net/2021/12/10/SGROw8Btcq4bFpm.png" alt="image-20211210234030600"></p>
<p>4、还要加上一个主机记录为@的，这代表不需要前缀，直接域名就能访问，例如我的：ylxlogan.top</p>
<p><img src="https://s2.loli.net/2021/12/10/qaPfG4QvgKOm8TD.png" alt="image-20211210234218799"></p>
<p>5、回到Github仓库目录中，在根目录下创建一个文件CNAME，然后在里面添加域名，我添加的是ylxlogan.top.</p>
<p><img src="https://s2.loli.net/2021/12/10/qc691rjwXafvOil.png" alt="image-20211210234518922"></p>
<p><img src="https://s2.loli.net/2021/12/10/VK4iz5MCj9LyhlP.png" alt="image-20211210234559845"></p>
<p><img src="https://s2.loli.net/2021/12/10/m6dCYP3VWXocNnE.png" alt="image-20211210234634170"></p>
<p>6、点击setting—》pages，如果创建了CNAME文件，那么这里会自动显示域名，没有的话可以手动添加，然后保存。</p>
<p><img src="https://s2.loli.net/2021/12/10/bNhCGEFP7RwrWtM.png" alt="image-20211210234833348"></p>
<p>7、等待检测，可能需要5分钟左右，当出现域名后面出现绿色的勾，说明域名绑定成功，可以使用域名访问博客了。</p>
<p><img src="https://s2.loli.net/2021/12/10/Fn78heCGPIjAmKD.png" alt="image-20211210235012093"></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>hexo+github博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>博客bug</title>
    <url>/2021/12/13/%E5%8D%9A%E5%AE%A2bug/</url>
    <content><![CDATA[<p>博客bug记录：</p>
<p>一、无法显示问题</p>
<p>1、关于我的页面，编辑之后无法正常显示，不清楚原因，本地调试没有问题但是部署到了github之后就无法正常显示了。经过测试并不是信息敏感的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决：</span><br><span class="line">	重新创建关于我的文件和路径，参照tags和categories一样</span><br><span class="line">	因为部署的是github上，所以国内加载</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
        <category>博客bug</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>博客测试</title>
    <url>/2021/12/11/%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="博客测试内容"><a href="#博客测试内容" class="headerlink" title="博客测试内容"></a>博客测试内容</h1><h2 id="1、网页是否正常显示✔"><a href="#1、网页是否正常显示✔" class="headerlink" title="1、网页是否正常显示✔"></a>1、网页是否正常显示✔</h2><h2 id="2、右上角的进入我的github✔"><a href="#2、右上角的进入我的github✔" class="headerlink" title="2、右上角的进入我的github✔"></a>2、右上角的进入我的github✔</h2><h2 id="3、分类侧边栏一级分类功能✔"><a href="#3、分类侧边栏一级分类功能✔" class="headerlink" title="3、分类侧边栏一级分类功能✔"></a>3、分类侧边栏一级分类功能✔</h2><h2 id="4、分类侧边栏二级分类功能✔"><a href="#4、分类侧边栏二级分类功能✔" class="headerlink" title="4、分类侧边栏二级分类功能✔"></a>4、分类侧边栏二级分类功能✔</h2><h2 id="5、一篇文章多个标签✔"><a href="#5、一篇文章多个标签✔" class="headerlink" title="5、一篇文章多个标签✔"></a>5、一篇文章多个标签✔</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">categories:</span><br><span class="line">- [父目录一, 子目录一]</span><br><span class="line">- [父目录一, 子目录二]</span><br><span class="line">- [父目录二]</span><br><span class="line">tags: </span><br><span class="line">  - 标签一</span><br><span class="line">  - 标签二</span><br></pre></td></tr></table></figure>

<h2 id="6、网页，文章浏览量✔"><a href="#6、网页，文章浏览量✔" class="headerlink" title="6、网页，文章浏览量✔"></a>6、网页，文章浏览量✔</h2><h2 id="7、文章评论功能，以及回复功能✔"><a href="#7、文章评论功能，以及回复功能✔" class="headerlink" title="7、文章评论功能，以及回复功能✔"></a>7、文章评论功能，以及回复功能✔</h2><ul>
<li><p>第一步  </p>
<ul>
<li>进行<a href="https://console.leancloud.cn/register">注册 · LeanCloud</a><ul>
<li><img src="https://s2.loli.net/2021/12/11/JInYD3r8POcZlyw.png" alt="image-20211211185231872" style="zoom: 50%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>第二步 </p>
<ul>
<li>注册完成之后登陆，在应用当中创建应用<ul>
<li><img src="https://s2.loli.net/2021/12/11/4RPzXMc7rjoFbWG.png" alt="image-20211211185515048" style="zoom: 50%;" /></li>
<li>自定义应用名称之后，点击创建</li>
</ul>
</li>
</ul>
</li>
<li><p>第三步</p>
<ul>
<li>点击设置，选择凭证<ul>
<li><img src="https://s2.loli.net/2021/12/11/MWpz2OmLotrZRD9.png" alt="image-20211211185740100" style="zoom:67%;" /></li>
</ul>
</li>
<li>回到主题配置文件里面，找到Valine这里，按照对应id，key粘贴<ul>
<li><img src="https://s2.loli.net/2021/12/11/1Y3Kptb54nrHCwa.png" alt="image-20211211190038352" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>第四步，完成功能的实现！！！</p>
</li>
</ul>
<h2 id="8、文章视频播放（待测试）"><a href="#8、文章视频播放（待测试）" class="headerlink" title="8、文章视频播放（待测试）"></a>8、文章视频播放（<strong>待测试</strong>）</h2><h2 id="9、文章音乐播放（待测试）"><a href="#9、文章音乐播放（待测试）" class="headerlink" title="9、文章音乐播放（待测试）"></a>9、文章音乐播放（<strong>待测试</strong>）</h2><h2 id="10、全局搜索功能✔"><a href="#10、全局搜索功能✔" class="headerlink" title="10、全局搜索功能✔"></a>10、全局搜索功能✔</h2><ul>
<li><p><strong>注意</strong>：</p>
<p>​        写文章的时候，尽量不要有特殊字符，否则搜索功能会失效</p>
</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
        <category>博客功能测试</category>
      </categories>
      <tags>
        <tag>博客功能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>博客迁移</title>
    <url>/2021/12/14/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E8%87%AA%E5%B7%B1%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>博客迁移到自己的阿里云服务器</p>
<p>​    暂时没有成功，我将用在github上面的域名无法用到自己的服务器地址，导致无法访问，后续努力！</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>博客迁移</category>
      </categories>
      <tags>
        <tag>博客迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>消息模型Pulsar</title>
    <url>/2021/12/14/Apach%20Pulsar%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="消息模型Pulsar"><a href="#消息模型Pulsar" class="headerlink" title="消息模型Pulsar"></a>消息模型Pulsar</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    当用户选择一个消息系统的时候，消息模型是用户第一个要考虑的事情，不论是一个什么系统，他都需要提前选定一个框架，对我来说就是一个模型，有了模型之后，就能生产产品了，照着它的样子做成自己的东西，其实我们所做的任何东西都是有最初使的模型的。</p>
<p>​    那么对于消息模型，我们就应该考虑消息最重要的内容，就像人必须有内脏一样：</p>
<ul>
<li>消息消费：我们需要确定如何发送和消费消息</li>
<li>消息确认（ack）：如何确认消息</li>
<li>消息保存：消息保存多长时间，以及消息通过什么方式触发某些操作，例如删除。</li>
</ul>
<h2 id="消息消费模型"><a href="#消息消费模型" class="headerlink" title="消息消费模型"></a>消息消费模型</h2><p>​    消息消费分为两种：一个是队列（Queue）、另一个是流</p>
<ul>
<li><p>队列（无需，通常与无状态应用结合、可以创建多个消费者<code>一个队列一个队列的传可以分开</code>）</p>
<ul>
<li>RabbitMQ</li>
<li>RocketMQ</li>
</ul>
</li>
<li><p>流（有序，通常与有状态应用结合，始终只会有一个消费者<code>水流不能切断，如果多个消费者切换，这过程水流可能会丢失</code>）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>BigData</category>
        <category>消息模型Pulsar</category>
      </categories>
      <tags>
        <tag>Pulsar</tag>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL杂记</title>
    <url>/2021/12/23/MySQL%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MySQL杂记"><a href="#MySQL杂记" class="headerlink" title="MySQL杂记"></a>MySQL杂记</h1><p>1、MySQL中的update不能出现在子查询语句中</p>
<p>2、更新binlog日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table_name set version = version+1 where ....;</span><br></pre></td></tr></table></figure>

<p>3、hive中收集函数为：collect_set()、collect_list()</p>
<p>​            - mysql中的收集元素的函数为：group_concat(column_name)</p>
<p>4、拼接函数：concat_ws(‘分隔符’,元素)，concat(元素，‘分隔符’，元素)</p>
]]></content>
      <categories>
        <category>BigData</category>
        <category>MySQL杂记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive中sql练习</title>
    <url>/2021/12/22/HIve%E4%B8%ADsql%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一、行列转换"><a href="#一、行列转换" class="headerlink" title="一、行列转换"></a>一、行列转换</h2><p>描述：表中记录了各年份各部门的平均绩效考核成绩。</p>
<p>表名：t1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表结构：</span><br><span class="line">a -- 年份</span><br><span class="line">b -- 部门</span><br><span class="line">c -- 绩效得分</span><br></pre></td></tr></table></figure>



<p>表内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> a  b c</span><br><span class="line">2014 B 9</span><br><span class="line">2015 A 8</span><br><span class="line">2014 A 10</span><br><span class="line">2015 B 7</span><br></pre></td></tr></table></figure>



<h4 id="问题一：多行转多列"><a href="#问题一：多行转多列" class="headerlink" title="问题一：多行转多列"></a>问题一：多行转多列</h4><p>问题描述：将上述表内容转为如下输出结果所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a col_A col_B</span><br><span class="line">2014 10  9</span><br><span class="line">2015 8  7</span><br></pre></td></tr></table></figure>



<p>参考答案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  a,</span><br><span class="line">  <span class="built_in">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> b<span class="operator">=</span>&quot;A&quot; <span class="keyword">then</span> c <span class="keyword">end</span>) col_A,</span><br><span class="line">  <span class="built_in">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> b<span class="operator">=</span>&quot;B&quot; <span class="keyword">then</span> c <span class="keyword">end</span>) col_B</span><br><span class="line"><span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure>



<h4 id="问题二：如何将结果转成源表？（多列转多行）"><a href="#问题二：如何将结果转成源表？（多列转多行）" class="headerlink" title="问题二：如何将结果转成源表？（多列转多行）"></a>问题二：如何将结果转成源表？（多列转多行）</h4><p>问题描述：将问题一的结果转成源表，问题一结果表名为t1_2。</p>
<p>参考答案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  a,</span><br><span class="line">  b,</span><br><span class="line">  c</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span> a,&quot;A&quot; <span class="keyword">as</span> b,col_a <span class="keyword">as</span> c <span class="keyword">from</span> t1_2 </span><br><span class="line">  <span class="keyword">union</span> <span class="keyword">all</span> </span><br><span class="line">  <span class="keyword">select</span> a,&quot;B&quot; <span class="keyword">as</span> b,col_b <span class="keyword">as</span> c <span class="keyword">from</span> t1_2 </span><br><span class="line">)tmp; </span><br></pre></td></tr></table></figure>



<h4 id="问题三：同一部门会有多个绩效，求多行转多列结果"><a href="#问题三：同一部门会有多个绩效，求多行转多列结果" class="headerlink" title="问题三：同一部门会有多个绩效，求多行转多列结果"></a>问题三：同一部门会有多个绩效，求多行转多列结果</h4><p>问题描述：2014年公司组织架构调整，导致部门出现多个绩效，业务及人员不同，无法合并算绩效，源表内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">2014</span> B <span class="number">9</span></span><br><span class="line"><span class="number">2015</span> A <span class="number">8</span></span><br><span class="line"><span class="number">2014</span> A <span class="number">10</span></span><br><span class="line"><span class="number">2015</span> B <span class="number">7</span></span><br><span class="line"><span class="number">2014</span> B <span class="number">6</span></span><br></pre></td></tr></table></figure>



<p>输出结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> a  col_A col_B</span><br><span class="line"><span class="number">2014</span>  <span class="number">10</span>  <span class="number">6</span>,<span class="number">9</span></span><br><span class="line"><span class="number">2015</span>  <span class="number">8</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>



<p>参考答案:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  a,</span><br><span class="line">  <span class="built_in">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> b<span class="operator">=</span>&quot;A&quot; <span class="keyword">then</span> c <span class="keyword">end</span>) col_A,</span><br><span class="line">  <span class="built_in">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> b<span class="operator">=</span>&quot;B&quot; <span class="keyword">then</span> c <span class="keyword">end</span>) col_B</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span> </span><br><span class="line">    a,</span><br><span class="line">   b,</span><br><span class="line">    concat_ws(&quot;,&quot;,collect_set(<span class="built_in">cast</span>(c <span class="keyword">as</span> string))) <span class="keyword">as</span> c</span><br><span class="line">  <span class="keyword">from</span> t1</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> a,b</span><br><span class="line">)tmp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure>



<h2 id="二、排名中取他值"><a href="#二、排名中取他值" class="headerlink" title="二、排名中取他值"></a>二、排名中取他值</h2><p>表名：t2</p>
<p>表字段及内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">a  b  c</span><br><span class="line"><span class="number">2014</span> A  <span class="number">3</span></span><br><span class="line"><span class="number">2014</span> B  <span class="number">1</span></span><br><span class="line"><span class="number">2014</span> C  <span class="number">2</span></span><br><span class="line"><span class="number">2015</span> A  <span class="number">4</span></span><br><span class="line"><span class="number">2015</span> D  <span class="number">3</span></span><br></pre></td></tr></table></figure>



<h4 id="问题一：按a分组取b字段最小时对应的c字段"><a href="#问题一：按a分组取b字段最小时对应的c字段" class="headerlink" title="问题一：按a分组取b字段最小时对应的c字段"></a>问题一：按a分组取b字段最小时对应的c字段</h4><p>输出结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">a  min_c</span><br><span class="line"><span class="number">2014</span> <span class="number">3</span></span><br><span class="line"><span class="number">2015</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>参考答案:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> a,</span><br><span class="line"> c <span class="keyword">as</span> min_c</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">   <span class="keyword">select</span></span><br><span class="line">​    a,</span><br><span class="line">​    b,</span><br><span class="line">​    c,</span><br><span class="line">​    <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b) <span class="keyword">as</span> rn </span><br><span class="line">   <span class="keyword">from</span> t2 </span><br><span class="line">)a</span><br><span class="line"><span class="keyword">where</span> rn <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h4 id="问题二：按a分组取b字段排第二时对应的c字段"><a href="#问题二：按a分组取b字段排第二时对应的c字段" class="headerlink" title="问题二：按a分组取b字段排第二时对应的c字段"></a>问题二：按a分组取b字段排第二时对应的c字段</h4><p>输出结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> a second_c</span><br><span class="line"><span class="number">2014</span> <span class="number">1</span></span><br><span class="line"><span class="number">2015</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>



<p>参考答案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> a,</span><br><span class="line"> c <span class="keyword">as</span> second_c</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">   <span class="keyword">select</span></span><br><span class="line">​    a,</span><br><span class="line">​    b,</span><br><span class="line">​    c,</span><br><span class="line">​    <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b) <span class="keyword">as</span> rn </span><br><span class="line">   <span class="keyword">from</span> t2 </span><br><span class="line">)a</span><br><span class="line"><span class="keyword">where</span> rn <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<h4 id="问题三：按a分组取b字段最小和最大时对应的c字段"><a href="#问题三：按a分组取b字段最小和最大时对应的c字段" class="headerlink" title="问题三：按a分组取b字段最小和最大时对应的c字段"></a>问题三：按a分组取b字段最小和最大时对应的c字段</h4><p>输出结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">a  min_c max_c</span><br><span class="line"><span class="number">2014</span> <span class="number">3</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2015</span> <span class="number">4</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>



<p>参考答案:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> a,</span><br><span class="line"> <span class="built_in">min</span>(if(asc_rn <span class="operator">=</span> <span class="number">1</span>, c, <span class="keyword">null</span>)) <span class="keyword">as</span> min_c,</span><br><span class="line"> <span class="built_in">max</span>(if(desc_rn <span class="operator">=</span> <span class="number">1</span>, c, <span class="keyword">null</span>)) <span class="keyword">as</span> max_c</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">   <span class="keyword">select</span></span><br><span class="line">​    a,</span><br><span class="line">​    b,</span><br><span class="line">​    c,</span><br><span class="line">​    <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b) <span class="keyword">as</span> asc_rn,</span><br><span class="line">​    <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">desc</span>) <span class="keyword">as</span> desc_rn </span><br><span class="line">   <span class="keyword">from</span> t2 </span><br><span class="line">)a</span><br><span class="line"><span class="keyword">where</span> asc_rn <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> desc_rn <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a; </span><br></pre></td></tr></table></figure>



<h4 id="问题四：按a分组取b字段第二小和第二大时对应的c字段"><a href="#问题四：按a分组取b字段第二小和第二大时对应的c字段" class="headerlink" title="问题四：按a分组取b字段第二小和第二大时对应的c字段"></a>问题四：按a分组取b字段第二小和第二大时对应的c字段</h4><p>输出结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">a  min_c max_c</span><br><span class="line"><span class="number">2014</span> <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"><span class="number">2015</span> <span class="number">3</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>参考答案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  ret.a</span><br><span class="line">  ,<span class="built_in">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> ret.rn_min <span class="operator">=</span> <span class="number">2</span> <span class="keyword">then</span> ret.c <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> min_c</span><br><span class="line">  ,<span class="built_in">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> ret.rn_max <span class="operator">=</span> <span class="number">2</span> <span class="keyword">then</span> ret.c <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> max_c</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span></span><br><span class="line">​    </span><br><span class="line">​    ,<span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> t2.a <span class="keyword">order</span> <span class="keyword">by</span> t2.b) <span class="keyword">as</span> rn_min</span><br><span class="line">​    ,<span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> t2.a <span class="keyword">order</span> <span class="keyword">by</span> t2.b <span class="keyword">desc</span>) <span class="keyword">as</span> rn_max</span><br><span class="line">  <span class="keyword">from</span> t2</span><br><span class="line">) <span class="keyword">as</span> ret</span><br><span class="line"><span class="keyword">where</span> ret.rn_min <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">or</span> ret.rn_max <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ret.a;</span><br></pre></td></tr></table></figure>



<h4 id="问题五：按a分组取b字段前两小和前两大时对应的c字段"><a href="#问题五：按a分组取b字段前两小和前两大时对应的c字段" class="headerlink" title="问题五：按a分组取b字段前两小和前两大时对应的c字段"></a>问题五：按a分组取b字段前两小和前两大时对应的c字段</h4><p>注意：需保持b字段最小、最大排首位</p>
<p>输出结果如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">a  min_c max_c</span><br><span class="line"><span class="number">2014</span> <span class="number">3</span>,<span class="number">1</span>   <span class="number">2</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2015</span> <span class="number">4</span>,<span class="number">3</span>   <span class="number">3</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>参考答案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> tmp1.a <span class="keyword">as</span> a,</span><br><span class="line"> min_c,</span><br><span class="line"> max_c</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"> <span class="keyword">select</span> </span><br><span class="line">  a,</span><br><span class="line">  concat_ws(<span class="string">&#x27;,&#x27;</span>, collect_list(c)) <span class="keyword">as</span> min_c</span><br><span class="line"> <span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">   <span class="keyword">select</span></span><br><span class="line">​    a,</span><br><span class="line">​    b,</span><br><span class="line">​    c,</span><br><span class="line">​    <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b) <span class="keyword">as</span> asc_rn</span><br><span class="line">   <span class="keyword">from</span> t2</span><br><span class="line">   )a</span><br><span class="line">  <span class="keyword">where</span> asc_rn <span class="operator">&lt;=</span> <span class="number">2</span> </span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> a </span><br><span class="line">)tmp1 </span><br><span class="line"><span class="keyword">join</span> </span><br><span class="line">(</span><br><span class="line"> <span class="keyword">select</span> </span><br><span class="line">  a,</span><br><span class="line">  concat_ws(<span class="string">&#x27;,&#x27;</span>, collect_list(c)) <span class="keyword">as</span> max_c</span><br><span class="line"> <span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">   <span class="keyword">select</span></span><br><span class="line">​    a,</span><br><span class="line">​    b,</span><br><span class="line">​    c,</span><br><span class="line">​    <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">desc</span>) <span class="keyword">as</span> desc_rn </span><br><span class="line">   <span class="keyword">from</span> t2</span><br><span class="line">  )a</span><br><span class="line">  <span class="keyword">where</span> desc_rn <span class="operator">&lt;=</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> a </span><br><span class="line">)tmp2 </span><br><span class="line"><span class="keyword">on</span> tmp1.a <span class="operator">=</span> tmp2.a; </span><br></pre></td></tr></table></figure>



<h2 id="三、累计求值"><a href="#三、累计求值" class="headerlink" title="三、累计求值"></a>三、累计求值</h2><p>表名：t3</p>
<p>表字段及内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  b  c</span><br><span class="line">2014 A  3</span><br><span class="line">2014 B  1</span><br><span class="line">2014 C  2</span><br><span class="line">2015 A  4</span><br><span class="line">2015 D  3</span><br></pre></td></tr></table></figure>



<h4 id="问题一：按a分组按b字段排序，对c累计求和"><a href="#问题一：按a分组按b字段排序，对c累计求和" class="headerlink" title="问题一：按a分组按b字段排序，对c累计求和"></a>问题一：按a分组按b字段排序，对c累计求和</h4><p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  b  sum_c</span><br><span class="line">2014 A  3</span><br><span class="line">2014 B  4</span><br><span class="line">2014 C  6</span><br><span class="line">2015 A  4</span><br><span class="line">2015 D  7</span><br></pre></td></tr></table></figure>



<p>参考答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line"> a, </span><br><span class="line"> b, </span><br><span class="line"> c, </span><br><span class="line"> sum(c) over(partition by a order by b) as sum_c</span><br><span class="line">from t3; </span><br></pre></td></tr></table></figure>



<h4 id="问题二：按a分组按b字段排序，对c取累计平均值"><a href="#问题二：按a分组按b字段排序，对c取累计平均值" class="headerlink" title="问题二：按a分组按b字段排序，对c取累计平均值"></a>问题二：按a分组按b字段排序，对c取累计平均值</h4><p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  b  avg_c</span><br><span class="line">2014 A  3</span><br><span class="line">2014 B  2</span><br><span class="line">2014 C  2</span><br><span class="line">2015 A  4</span><br><span class="line">2015 D  3.5</span><br></pre></td></tr></table></figure>



<p>参考答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line"> a, </span><br><span class="line"> b, </span><br><span class="line"> c, </span><br><span class="line"> avg(c) over(partition by a order by b) as avg_c</span><br><span class="line">from t3;</span><br></pre></td></tr></table></figure>



<h4 id="问题三：按a分组按b字段排序，对b取累计排名比例"><a href="#问题三：按a分组按b字段排序，对b取累计排名比例" class="headerlink" title="问题三：按a分组按b字段排序，对b取累计排名比例"></a>问题三：按a分组按b字段排序，对b取累计排名比例</h4><p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  b  ratio_c</span><br><span class="line">2014 A  0.33</span><br><span class="line">2014 B  0.67</span><br><span class="line">2014 C  1.00</span><br><span class="line">2015 A  0.50</span><br><span class="line">2015 D  1.00</span><br></pre></td></tr></table></figure>



<p>参考答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line"> a, </span><br><span class="line"> b, </span><br><span class="line"> c, </span><br><span class="line">round(row_number() over(partition by a order by b) / (count(c) over(partition by a)),2) as ratio_c</span><br><span class="line">from t3 </span><br><span class="line">order by a,b;</span><br></pre></td></tr></table></figure>



<h4 id="问题四：按a分组按b字段排序，对b取累计求和比例"><a href="#问题四：按a分组按b字段排序，对b取累计求和比例" class="headerlink" title="问题四：按a分组按b字段排序，对b取累计求和比例"></a>问题四：按a分组按b字段排序，对b取累计求和比例</h4><p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  b  ratio_c</span><br><span class="line">2014 A  0.50</span><br><span class="line">2014 B  0.67</span><br><span class="line">2014 C  1.00</span><br><span class="line">2015 A  0.57</span><br><span class="line">2015 D  1.00</span><br></pre></td></tr></table></figure>



<p>参考答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line"> a, </span><br><span class="line"> b, </span><br><span class="line"> c, </span><br><span class="line"> round(sum(c) over(partition by a order by b) / (sum(c) over(partition by a)),2) as ratio_c</span><br><span class="line">from t3 </span><br><span class="line">order by a,b;</span><br></pre></td></tr></table></figure>



<h2 id="四、窗口大小控制"><a href="#四、窗口大小控制" class="headerlink" title="四、窗口大小控制"></a>四、窗口大小控制</h2><p>表名：t4</p>
<p>表字段及内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  b  c</span><br><span class="line">2014 A  3</span><br><span class="line">2014 B  1</span><br><span class="line">2014 C  2</span><br><span class="line">2015 A  4</span><br><span class="line">2015 D  3</span><br></pre></td></tr></table></figure>



<h4 id="问题一：按a分组按b字段排序，对c取前后各一行的和"><a href="#问题一：按a分组按b字段排序，对c取前后各一行的和" class="headerlink" title="问题一：按a分组按b字段排序，对c取前后各一行的和"></a>问题一：按a分组按b字段排序，对c取前后各一行的和</h4><p>输出结果如下所示：</p>
<p>a  b  sum_c</p>
<p>2014 A  1</p>
<p>2014 B  5</p>
<p>2014 C  1</p>
<p>2015 A  3</p>
<p>2015 D  4</p>
<p>参考答案：</p>
<p>select </p>
<p> a,</p>
<p> b,</p>
<p> lag(c,1,0) over(partition by a order by b)+lead(c,1,0) over(partition by a order by b) as sum_c</p>
<p>from t4;</p>
<h4 id="问题二：按a分组按b字段排序，对c取平均值"><a href="#问题二：按a分组按b字段排序，对c取平均值" class="headerlink" title="问题二：按a分组按b字段排序，对c取平均值"></a>问题二：按a分组按b字段排序，对c取平均值</h4><p>问题描述：前一行与当前行的均值！</p>
<p>输出结果如下所示：</p>
<p>a  b  avg_c</p>
<p>2014 A  3</p>
<p>2014 B  2</p>
<p>2014 C  1.5</p>
<p>2015 A  4</p>
<p>2015 D  3.5</p>
<p>参考答案：</p>
<p>select</p>
<p> a,</p>
<p> b,</p>
<p> case when lag_c is null then c</p>
<p> else (c+lag_c)/2 end as avg_c</p>
<p>from</p>
<p> (</p>
<p> select</p>
<p>  a,</p>
<p>  b,</p>
<p>  c,</p>
<p>  lag(c,1) over(partition by a order by b) as lag_c</p>
<p> from t4</p>
<p> )temp;</p>
<h2 id="五、产生连续数值"><a href="#五、产生连续数值" class="headerlink" title="五、产生连续数值"></a>五、产生连续数值</h2><p>输出结果如下所示：</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>…</p>
<p>100</p>
<p>参考答案：</p>
<p>不借助其他任何外表，实现产生连续数值</p>
<p>此处给出两种解法，其一：</p>
<p>select</p>
<p>id_start+pos as id</p>
<p>from(</p>
<p>  select</p>
<p>  1 as id_start,</p>
<p>  1000000 as id_end</p>
<p>) m lateral view posexplode(split(space(id_end-id_start), ‘’)) t as pos, val</p>
<p>其二：</p>
<p>select</p>
<p> row_number() over() as id</p>
<p>from </p>
<p> (select split(space(99), ‘ ‘) as x) t</p>
<p>lateral view</p>
<p>explode(x) ex;</p>
<p>那如何产生1至1000000连续数值？</p>
<p>参考答案：</p>
<p>select</p>
<p> row_number() over() as id</p>
<p>from </p>
<p> (select split(space(999999), ‘ ‘) as x) t</p>
<p>lateral view</p>
<p>explode(x) ex;</p>
<h2 id="六、数据扩充与收缩"><a href="#六、数据扩充与收缩" class="headerlink" title="六、数据扩充与收缩"></a>六、数据扩充与收缩</h2><p>表名：t6</p>
<p>表字段及内容：</p>
<p>a</p>
<p>3</p>
<p>2</p>
<p>4</p>
<h4 id="问题一：数据扩充"><a href="#问题一：数据扩充" class="headerlink" title="问题一：数据扩充"></a>问题一：数据扩充</h4><p>输出结果如下所示：</p>
<p>a   b</p>
<p>3  3、2、1</p>
<p>2  2、1</p>
<p>4  4、3、2、1</p>
<p>参考答案：</p>
<p>select </p>
<p> t.a,</p>
<p> concat_ws(‘、’,collect_set(cast(t.rn as string))) as b</p>
<p>from</p>
<p>( </p>
<p> select </p>
<p>  t6.a,</p>
<p>  b.rn</p>
<p> from t6</p>
<p> left join</p>
<p> ( </p>
<p>  select</p>
<p>   row_number() over() as rn</p>
<p>  from </p>
<p>  (select split(space(5), ‘ ‘) as x) t – space(5)可根据t6表的最大值灵活调整</p>
<p>  lateral view</p>
<p>  explode(x) pe</p>
<p> ) b</p>
<p> on 1 = 1</p>
<p> where t6.a &gt;= b.rn</p>
<p> order by t6.a, b.rn desc </p>
<p>) t</p>
<p>group by t.a;</p>
<h4 id="问题二：数据扩充，排除偶数"><a href="#问题二：数据扩充，排除偶数" class="headerlink" title="问题二：数据扩充，排除偶数"></a>问题二：数据扩充，排除偶数</h4><p>输出结果如下所示：</p>
<p>a   b</p>
<p>3  3、1</p>
<p>2  1</p>
<p>4  3、1</p>
<p>参考答案：</p>
<p>select </p>
<p> t.a,</p>
<p> concat_ws(‘、’,collect_set(cast(t.rn as string))) as b</p>
<p>from</p>
<p>( </p>
<p> select </p>
<p>  t6.a,</p>
<p>  b.rn</p>
<p> from t6</p>
<p> left join</p>
<p> ( </p>
<p>  select</p>
<p>   row_number() over() as rn</p>
<p>  from </p>
<p>  (select split(space(5), ‘ ‘) as x) t</p>
<p>  lateral view</p>
<p>  explode(x) pe</p>
<p> ) b</p>
<p> on 1 = 1</p>
<p> where t6.a &gt;= b.rn and b.rn % 2 = 1</p>
<p> order by t6.a, b.rn desc </p>
<p>) t</p>
<p>group by t.a;</p>
<h4 id="问题三：如何处理字符串累计拼接"><a href="#问题三：如何处理字符串累计拼接" class="headerlink" title="问题三：如何处理字符串累计拼接"></a>问题三：如何处理字符串累计拼接</h4><p>问题描述：将小于等于a字段的值聚合拼接起来</p>
<p>输出结果如下所示：</p>
<p>a   b</p>
<p>3   2、3</p>
<p>2   2</p>
<p>4   2、3、4</p>
<p>参考答案：</p>
<p>select </p>
<p> t.a,</p>
<p> concat_ws(‘、’,collect_set(cast(t.a1 as string))) as b</p>
<p>from</p>
<p>(  </p>
<p> select </p>
<p>  t6.a,</p>
<p>  b.a1</p>
<p> from t6</p>
<p> left join</p>
<p> (  </p>
<p>  select a as a1 </p>
<p>  from t6</p>
<p> ) b</p>
<p> on 1 = 1</p>
<p> where t6.a &gt;= b.a1</p>
<p> order by t6.a, b.a1 </p>
<p>) t</p>
<p>group by t.a;</p>
<h4 id="问题四：如果a字段有重复，如何实现字符串累计拼接"><a href="#问题四：如果a字段有重复，如何实现字符串累计拼接" class="headerlink" title="问题四：如果a字段有重复，如何实现字符串累计拼接"></a>问题四：如果a字段有重复，如何实现字符串累计拼接</h4><p>输出结果如下所示：</p>
<p>a   b</p>
<p>2   2</p>
<p>3   2、3</p>
<p>3   2、3、3</p>
<p>4   2、3、3、4</p>
<p>参考答案：</p>
<p>select </p>
<p> a,</p>
<p> b</p>
<p>from </p>
<p>(</p>
<p> select </p>
<p>  t.a,</p>
<p>  t.rn,</p>
<p>  concat_ws(‘、’,collect_list(cast(t.a1 as string))) as b</p>
<p> from</p>
<p> (  </p>
<p>  select </p>
<p>   a.a,</p>
<p>   a.rn,</p>
<p>   b.a1</p>
<p>  from</p>
<p>  (</p>
<p>   select </p>
<p>​    a,</p>
<p>​    row_number() over(order by a ) as rn </p>
<p>   from t6</p>
<p>  ) a</p>
<p>  left join</p>
<p>  (  </p>
<p>   select a as a1,</p>
<p>   row_number() over(order by a ) as rn </p>
<p>   from t6</p>
<p>  ) b</p>
<p>  on 1 = 1</p>
<p>  where a.a &gt;= b.a1 and a.rn &gt;= b.rn </p>
<p>  order by a.a, b.a1 </p>
<p> ) t</p>
<p> group by t.a,t.rn</p>
<p> order by t.a,t.rn</p>
<p>) tt; </p>
<h4 id="问题五：数据展开"><a href="#问题五：数据展开" class="headerlink" title="问题五：数据展开"></a>问题五：数据展开</h4><p>问题描述：如何将字符串”1-5,16,11-13,9”扩展成”1,2,3,4,5,16,11,12,13,9”？注意顺序不变。</p>
<p>参考答案：</p>
<p>select </p>
<p> concat_ws(‘,’,collect_list(cast(rn as string)))</p>
<p>from</p>
<p>(</p>
<p> select </p>
<p>  a.rn,</p>
<p>  b.num,</p>
<p>  b.pos</p>
<p> from</p>
<p>  (</p>
<p>  select</p>
<p>   row_number() over() as rn</p>
<p>  from (select split(space(20), ‘ ‘) as x) t – space(20)可灵活调整</p>
<p>  lateral view</p>
<p>  explode(x) pe</p>
<p>  ) a lateral view outer </p>
<p>  posexplode(split(‘1-5,16,11-13,9’, ‘,’)) b as pos, num</p>
<p>  where a.rn between cast(split(num, ‘-‘)[0] as int) and cast(split(num, ‘-‘)[1] as int) or a.rn = num</p>
<p>  order by pos, rn </p>
<p>) t;</p>
<h2 id="七、合并与拆分"><a href="#七、合并与拆分" class="headerlink" title="七、合并与拆分"></a>七、合并与拆分</h2><p>表名：t7</p>
<p>表字段及内容：</p>
<p>a  b</p>
<p>2014 A</p>
<p>2014 B</p>
<p>2015 B</p>
<p>2015 D</p>
<h4 id="问题一：合并"><a href="#问题一：合并" class="headerlink" title="问题一：合并"></a>问题一：合并</h4><p>输出结果如下所示：</p>
<p>2014 A、B</p>
<p>2015 B、D</p>
<p>参考答案:</p>
<p>select</p>
<p> a,</p>
<p> concat_ws(‘、’, collect_set(t.b)) b</p>
<p>from t7</p>
<p>group by a;</p>
<h4 id="问题二：拆分"><a href="#问题二：拆分" class="headerlink" title="问题二：拆分"></a>问题二：拆分</h4><p>问题描述：将分组合并的结果拆分出来</p>
<p>参考答案：</p>
<p>select</p>
<p> t.a,</p>
<p> d</p>
<p>from</p>
<p>(</p>
<p> select</p>
<p> a,</p>
<p> concat_ws(‘、’, collect_set(t7.b)) b</p>
<p> from t7</p>
<p> group by a</p>
<p>)t</p>
<p>lateral view </p>
<p>explode(split(t.b, ‘、’)) table_tmp as d;</p>
<h2 id="八、模拟循环操作"><a href="#八、模拟循环操作" class="headerlink" title="八、模拟循环操作"></a>八、模拟循环操作</h2><p>表名：t8</p>
<p>表字段及内容：</p>
<p>a</p>
<p>1011</p>
<p>0101</p>
<h5 id="问题一：如何将字符’1’的位置提取出来"><a href="#问题一：如何将字符’1’的位置提取出来" class="headerlink" title="问题一：如何将字符’1’的位置提取出来"></a>问题一：如何将字符’1’的位置提取出来</h5><p>输出结果如下所示:</p>
<p>1,3,4</p>
<p>2,4</p>
<p>参考答案：</p>
<p>select </p>
<p>  a,</p>
<p>  concat_ws(“,”,collect_list(cast(index as string))) as res</p>
<p>from (</p>
<p>  select </p>
<p>​    a,</p>
<p>​    index+1 as index,</p>
<p>​    chr</p>
<p>  from (</p>
<p>​    select </p>
<p>​      a,</p>
<p>​      concat_ws(“,”,substr(a,1,1),substr(a,2,1),substr(a,3,1),substr(a,-1)) str</p>
<p>​    from t8</p>
<p>  ) tmp1</p>
<p>  lateral view posexplode(split(str,”,”)) t as index,chr</p>
<p>  where chr = “1”</p>
<p>) tmp2</p>
<p>group by a;</p>
<h2 id="九、不使用distinct或group-by去重"><a href="#九、不使用distinct或group-by去重" class="headerlink" title="九、不使用distinct或group by去重"></a>九、不使用distinct或group by去重</h2><p>表名：t9</p>
<p>表字段及内容：</p>
<p>a   b   c  d</p>
<p>2014 2016 2014  A</p>
<p>2014 2015 2015  B</p>
<h4 id="问题一：不使用distinct或group-by去重"><a href="#问题一：不使用distinct或group-by去重" class="headerlink" title="问题一：不使用distinct或group by去重"></a>问题一：不使用distinct或group by去重</h4><p>输出结果如下所示：</p>
<p>2014 A</p>
<p>2016 A</p>
<p>2014 B</p>
<p>2015 B</p>
<p>参考答案：</p>
<p>select</p>
<p> t2.year</p>
<p> ,t2.num</p>
<p>from</p>
<p> (</p>
<p> select</p>
<p>  ,row_number() over (partition by t1.year,t1.num) as rank_1</p>
<p> from </p>
<p> (</p>
<p>  select </p>
<p>   a as year,</p>
<p>   d as num</p>
<p>  from t9</p>
<p>  union all</p>
<p>  select </p>
<p>   b as year,</p>
<p>   d as num</p>
<p>  from t9</p>
<p>  union all</p>
<p>  select </p>
<p>   c as year,</p>
<p>   d as num</p>
<p>  from t9</p>
<p>  )t1</p>
<p>)t2</p>
<p>where rank_1=1</p>
<p>order by num;</p>
<h2 id="十、容器–反转内容"><a href="#十、容器–反转内容" class="headerlink" title="十、容器–反转内容"></a>十、容器–反转内容</h2><p>表名：t10</p>
<p>表字段及内容：</p>
<p>a</p>
<p>AB,CA,BAD</p>
<p>BD,EA</p>
<h4 id="问题一：反转逗号分隔的数据：改变顺序，内容不变"><a href="#问题一：反转逗号分隔的数据：改变顺序，内容不变" class="headerlink" title="问题一：反转逗号分隔的数据：改变顺序，内容不变"></a>问题一：反转逗号分隔的数据：改变顺序，内容不变</h4><p>输出结果如下所示：</p>
<p>BAD,CA,AB</p>
<p>EA,BD</p>
<p>参考答案：</p>
<p>select </p>
<p> a,</p>
<p> concat_ws(“,”,collect_list(reverse(str)))</p>
<p>from </p>
<p>(</p>
<p> select </p>
<p>  a,</p>
<p>  str</p>
<p> from t10</p>
<p> lateral view explode(split(reverse(a),”,”)) t as str</p>
<p>) tmp1</p>
<p>group by a;</p>
<h4 id="问题二：反转逗号分隔的数据：改变内容，顺序不变"><a href="#问题二：反转逗号分隔的数据：改变内容，顺序不变" class="headerlink" title="问题二：反转逗号分隔的数据：改变内容，顺序不变"></a>问题二：反转逗号分隔的数据：改变内容，顺序不变</h4><p>输出结果如下所示：</p>
<p>BA,AC,DAB</p>
<p>DB,AE</p>
<p>参考答案：</p>
<p>select </p>
<p> a,</p>
<p> concat_ws(“,”,collect_list(reverse(str)))</p>
<p>from </p>
<p>(</p>
<p> select </p>
<p>   a,</p>
<p>   str</p>
<p> from t10</p>
<p> lateral view explode(split(a,”,”)) t as str</p>
<p>) tmp1</p>
<p>group by a;</p>
<h2 id="十一、多容器–成对提取数据"><a href="#十一、多容器–成对提取数据" class="headerlink" title="十一、多容器–成对提取数据"></a>十一、多容器–成对提取数据</h2><p>表名：t11</p>
<p>表字段及内容：</p>
<p>a    b</p>
<p>A/B   1/3</p>
<p>B/C/D  4/5/2</p>
<h4 id="问题一：成对提取数据，字段一一对应"><a href="#问题一：成对提取数据，字段一一对应" class="headerlink" title="问题一：成对提取数据，字段一一对应"></a>问题一：成对提取数据，字段一一对应</h4><p>输出结果如下所示：</p>
<p>a    b</p>
<p>A    1</p>
<p>B    3</p>
<p>B    4</p>
<p>C    5</p>
<p>D    2</p>
<p>参考答案:</p>
<p>select </p>
<p> a_inx,</p>
<p> b_inx</p>
<p>from </p>
<p>(</p>
<p> select </p>
<p>   a,</p>
<p>   b,</p>
<p>   a_id,</p>
<p>   a_inx,</p>
<p>   b_id,</p>
<p>   b_inx</p>
<p> from t11</p>
<p> lateral view posexplode(split(a,’/‘)) t as a_id,a_inx</p>
<p> lateral view posexplode(split(b,’/‘)) t as b_id,b_inx</p>
<p>) tmp</p>
<p>where a_id=b_id;</p>
<h2 id="十二、多容器–转多行"><a href="#十二、多容器–转多行" class="headerlink" title="十二、多容器–转多行"></a>十二、多容器–转多行</h2><p>表名：t12</p>
<p>表字段及内容：</p>
<p>a    b   c</p>
<p>001   A/B   1/3/5</p>
<p>002   B/C/D  4/5</p>
<h4 id="问题一：转多行"><a href="#问题一：转多行" class="headerlink" title="问题一：转多行"></a>问题一：转多行</h4><p>输出结果如下所示：</p>
<p>a    d    e</p>
<p>001   type_b  A</p>
<p>001   type_b  B</p>
<p>001   type_c  1</p>
<p>001   type_c  3</p>
<p>001   type_c  5</p>
<p>002   type_b  B</p>
<p>002   type_b  C</p>
<p>002   type_b  D</p>
<p>002   type_c  4</p>
<p>002   type_c  5</p>
<p>参考答案:</p>
<p>select </p>
<p> a,</p>
<p> d,</p>
<p> e</p>
<p>from </p>
<p>(</p>
<p> select</p>
<p>  a,</p>
<p>  “type_b” as d,</p>
<p>  str as e</p>
<p> from t12</p>
<p> lateral view explode(split(b,”/“)) t as str</p>
<p> union all </p>
<p> select</p>
<p>  a,</p>
<p>  “type_c” as d,</p>
<p>  str as e</p>
<p> from t12</p>
<p> lateral view explode(split(c,”/“)) t as str</p>
<p>) tmp</p>
<p>order by a,d;</p>
<h2 id="十三、抽象分组–断点排序"><a href="#十三、抽象分组–断点排序" class="headerlink" title="十三、抽象分组–断点排序"></a>十三、抽象分组–断点排序</h2><p>表名：t13</p>
<p>表字段及内容：</p>
<p>a  b</p>
<p>2014 1</p>
<p>2015 1</p>
<p>2016 1</p>
<p>2017 0</p>
<p>2018 0</p>
<p>2019 -1</p>
<p>2020 -1</p>
<p>2021 -1</p>
<p>2022 1</p>
<p>2023 1</p>
<h4 id="问题一：断点排序"><a href="#问题一：断点排序" class="headerlink" title="问题一：断点排序"></a>问题一：断点排序</h4><p>输出结果如下所示：</p>
<p>a  b  c </p>
<p>2014 1  1</p>
<p>2015 1  2</p>
<p>2016 1  3</p>
<p>2017 0  1</p>
<p>2018 0  2</p>
<p>2019 -1  1</p>
<p>2020 -1  2</p>
<p>2021 -1  3</p>
<p>2022 1  1</p>
<p>2023 1  2</p>
<p>参考答案:</p>
<p>select </p>
<p> a,</p>
<p> b,</p>
<p> row_number() over( partition by b,repair_a order by a asc) as c–按照b列和[b的组首]分组，排序</p>
<p>from </p>
<p>(</p>
<p> select </p>
<p>  a,</p>
<p>  b,</p>
<p>  a-b_rn as repair_a–根据b列值出现的次序,修复a列值为b首次出现的a列值,称为b的[组首]</p>
<p> from </p>
<p> (</p>
<p>  select </p>
<p>   a,</p>
<p>   b,</p>
<p>   row_number() over( partition by b order by a asc ) as b_rn–按b列分组,按a列排序,得到b列各值出现的次序</p>
<p>  from t13 </p>
<p> )tmp1</p>
<p>)tmp2–注意，如果不同的b列值，可能出现同样的组首值，但组首值需要和a列值 一并参与分组，故并不影响排序。</p>
<p>order by a asc; </p>
<h2 id="十四、业务逻辑的分类与抽象–时效"><a href="#十四、业务逻辑的分类与抽象–时效" class="headerlink" title="十四、业务逻辑的分类与抽象–时效"></a>十四、业务逻辑的分类与抽象–时效</h2><p>日期表：d_date</p>
<p>表字段及内容：</p>
<p>date_id   is_work</p>
<p>2017-04-13    1</p>
<p>2017-04-14    1</p>
<p>2017-04-15    0</p>
<p>2017-04-16    0</p>
<p>2017-04-17    1</p>
<p>工作日：周一至周五09:30-18:30</p>
<p>客户申请表：t14</p>
<p>表字段及内容：</p>
<p>a   b    c</p>
<p>1   申请  2017-04-14 18:03:00</p>
<p>1   通过  2017-04-17 09:43:00</p>
<p>2   申请  2017-04-13 17:02:00</p>
<p>2   通过  2017-04-15 09:42:00</p>
<h4 id="问题一：计算上表中从申请到通过占用的工作时长"><a href="#问题一：计算上表中从申请到通过占用的工作时长" class="headerlink" title="问题一：计算上表中从申请到通过占用的工作时长"></a>问题一：计算上表中从申请到通过占用的工作时长</h4><p>输出结果如下所示：</p>
<p>a     d</p>
<p>1    0.67h</p>
<p>2    10.67h </p>
<p>参考答案:</p>
<p>select </p>
<p>  a,</p>
<p>  round(sum(diff)/3600,2) as d</p>
<p>from (</p>
<p>  select </p>
<p>​    a,</p>
<p>​    apply_time,</p>
<p>​    pass_time,</p>
<p>​    dates,</p>
<p>​    rn,</p>
<p>​    ct,</p>
<p>​    is_work,</p>
<p>​    case when is_work=1 and rn=1 then unix_timestamp(concat(dates,’ 18:30:00’),’yyyy-MM-dd HH:mm:ss’)-unix_timestamp(apply_time,’yyyy-MM-dd HH:mm:ss’)</p>
<p>​      when is_work=0 then 0</p>
<p>​      when is_work=1 and rn=ct then unix_timestamp(pass_time,’yyyy-MM-dd HH:mm:ss’)-unix_timestamp(concat(dates,’ 09:30:00’),’yyyy-MM-dd HH:mm:ss’)</p>
<p>​      when is_work=1 and rn!=ct then 93600</p>
<p>​    end diff</p>
<p>  from (</p>
<p>​    select </p>
<p>​      a,</p>
<p>​      apply_time,</p>
<p>​      pass_time,</p>
<p>​      time_diff,</p>
<p>​      day_diff,</p>
<p>​      rn,</p>
<p>​      ct,</p>
<p>​      date_add(start,rn-1) dates</p>
<p>​    from (</p>
<p>​      select </p>
<p>​        a,</p>
<p>​        apply_time,</p>
<p>​        pass_time,</p>
<p>​        time_diff,</p>
<p>​        day_diff,</p>
<p>​        strs,</p>
<p>​        start,</p>
<p>​        row_number() over(partition by a) as rn,</p>
<p>​        count() over(partition by a) as ct</p>
<p>​      from (</p>
<p>​        select </p>
<p>​          a,</p>
<p>​          apply_time,</p>
<p>​          pass_time,</p>
<p>​          time_diff,</p>
<p>​          day_diff,</p>
<p>​          substr(repeat(concat(substr(apply_time,1,10),’,’),day_diff+1),1,11(day_diff+1)-1) strs</p>
<p>​        from (</p>
<p>​          select </p>
<p>​            a,</p>
<p>​            apply_time,</p>
<p>​            pass_time,</p>
<p>​            unix_timestamp(pass_time,’yyyy-MM-dd HH:mm:ss’)-unix_timestamp(apply_time,’yyyy-MM-dd HH:mm:ss’) time_diff,</p>
<p>​            datediff(substr(pass_time,1,10),substr(apply_time,1,10)) day_diff</p>
<p>​          from (</p>
<p>​            select </p>
<p>​              a,</p>
<p>​              max(case when b=’申请’ then c end) apply_time,</p>
<p>​              max(case when b=’通过’ then c end) pass_time</p>
<p>​            from t14</p>
<p>​            group by a</p>
<p>​          ) tmp1</p>
<p>​        ) tmp2</p>
<p>​      ) tmp3 </p>
<p>​      lateral view explode(split(strs,”,”)) t as start</p>
<p>​    ) tmp4</p>
<p>  ) tmp5</p>
<p>  join d_date </p>
<p>  on tmp5.dates = d_date.date_id</p>
<p>) tmp6</p>
<p>group by a;</p>
<h2 id="十五、时间序列–进度及剩余"><a href="#十五、时间序列–进度及剩余" class="headerlink" title="十五、时间序列–进度及剩余"></a>十五、时间序列–进度及剩余</h2><p>表名：t15</p>
<p>表字段及内容：</p>
<p>date_id   is_work</p>
<p>2017-07-30   0</p>
<p>2017-07-31   1</p>
<p>2017-08-01   1</p>
<p>2017-08-02   1</p>
<p>2017-08-03   1</p>
<p>2017-08-04   1</p>
<p>2017-08-05   0</p>
<p>2017-08-06   0</p>
<p>2017-08-07   1</p>
<h4 id="问题一：求每天的累计周工作日，剩余周工作日"><a href="#问题一：求每天的累计周工作日，剩余周工作日" class="headerlink" title="问题一：求每天的累计周工作日，剩余周工作日"></a>问题一：求每天的累计周工作日，剩余周工作日</h4><p>输出结果如下所示：</p>
<p>date_id   week_to_work week_left_work</p>
<p>2017-07-31   1       4</p>
<p>2017-08-01   2       3</p>
<p>2017-08-02   3       2</p>
<p>2017-08-03   4       1</p>
<p>2017-08-04   5       0</p>
<p>2017-08-05   5       0</p>
<p>2017-08-06   5       0</p>
<p>参考答案:</p>
<p>此处给出两种解法，其一：</p>
<p>select </p>
<p> date_id</p>
<p>,case date_format(date_id,’u’)</p>
<p>  when 1 then 1</p>
<p>  when 2 then 2 </p>
<p>  when 3 then 3 </p>
<p>  when 4 then 4</p>
<p>  when 5 then 5 </p>
<p>  when 6 then 5 </p>
<p>  when 7 then 5 </p>
<p> end as week_to_work</p>
<p>,case date_format(date_id,’u’)</p>
<p>  when 1 then 4</p>
<p>  when 2 then 3 </p>
<p>  when 3 then 2 </p>
<p>  when 4 then 1</p>
<p>  when 5 then 0 </p>
<p>  when 6 then 0 </p>
<p>  when 7 then 0 </p>
<p> end as week_to_work</p>
<p>from t15</p>
<p>其二：</p>
<p>select</p>
<p>date_id,</p>
<p>week_to_work,</p>
<p>week_sum_work-week_to_work as week_left_work</p>
<p>from(</p>
<p>  select</p>
<p>  date_id,</p>
<p>  sum(is_work) over(partition by year,week order by date_id) as week_to_work,</p>
<p>  sum(is_work) over(partition by year,week) as week_sum_work</p>
<p>  from(</p>
<p>​    select</p>
<p>​    date_id,</p>
<p>​    is_work,</p>
<p>​    year(date_id) as year,</p>
<p>​    weekofyear(date_id) as week</p>
<p>​    from t15</p>
<p>  ) ta</p>
<p>) tb order by date_id;</p>
<h2 id="十六、时间序列–构造日期"><a href="#十六、时间序列–构造日期" class="headerlink" title="十六、时间序列–构造日期"></a>十六、时间序列–构造日期</h2><h4 id="问题一：直接使用SQL实现一张日期维度表，包含以下字段："><a href="#问题一：直接使用SQL实现一张日期维度表，包含以下字段：" class="headerlink" title="问题一：直接使用SQL实现一张日期维度表，包含以下字段："></a>问题一：直接使用SQL实现一张日期维度表，包含以下字段：</h4><p>date         string        日期</p>
<p>d_week        string        年内第几周</p>
<p>weeks        int         周几</p>
<p>w_start       string        周开始日</p>
<p>w_end        string        周结束日</p>
<p>d_month       int         第几月</p>
<p>m_start       string        月开始日</p>
<p>m_end        string        月结束日</p>
<p>d_quarter      int          第几季</p>
<p>q_start       string        季开始日</p>
<p>q_end        string        季结束日</p>
<p>d_year        int          年份</p>
<p>y_start       string        年开始日</p>
<p>y_end        string        年结束日</p>
<p>参考答案：</p>
<p>drop table if exists dim_date;</p>
<p>create table if not exists dim_date(</p>
<p>  <code>date</code> string comment ‘日期’,</p>
<p>  d_week string comment ‘年内第几周’,</p>
<p>  weeks string comment ‘周几’,</p>
<p>  w_start string comment ‘周开始日’,</p>
<p>  w_end string comment ‘周结束日’,</p>
<p>  d_month string comment ‘第几月’,</p>
<p>  m_start string comment ‘月开始日’,</p>
<p>  m_end string comment ‘月结束日’,</p>
<p>  d_quarter int comment ‘第几季’,</p>
<p>  q_start string comment ‘季开始日’,</p>
<p>  q_end string comment ‘季结束日’,</p>
<p>  d_year int comment ‘年份’,</p>
<p>  y_start string comment ‘年开始日’,</p>
<p>  y_end string comment ‘年结束日’</p>
<p>);</p>
<p>–自然月: 指每月的1号到那个月的月底，它是按照阳历来计算的。就是从每月1号到月底，不管这个月有30天，31天，29天或者28天，都算是一个自然月。</p>
<p>insert overwrite table dim_date</p>
<p>select <code>date</code></p>
<p>   , d_week –年内第几周</p>
<p>   , case weekid</p>
<p>​      when 0 then ‘周日’</p>
<p>​      when 1 then ‘周一’</p>
<p>​      when 2 then ‘周二’</p>
<p>​      when 3 then ‘周三’</p>
<p>​      when 4 then ‘周四’</p>
<p>​      when 5 then ‘周五’</p>
<p>​      when 6 then ‘周六’</p>
<p>  end as weeks – 周</p>
<p>   , date_add(next_day(<code>date</code>,’MO’),-7) as w_start –周一</p>
<p>   , date_add(next_day(<code>date</code>,’MO’),-1) as w_end  – 周日_end</p>
<p>   – 月份日期</p>
<p>   , concat(‘第’, monthid, ‘月’) as d_month</p>
<p>   , m_start</p>
<p>   , m_end</p>
<p>   – 季节</p>
<p>   , quarterid as d_quart</p>
<p>   , concat(d_year, ‘-‘, substr(concat(‘0’, (quarterid - 1)  3 + 1), -2), ‘-01’) as q_start –季开始日</p>
<p>   , date_sub(concat(d_year, ‘-‘, substr(concat(‘0’, (quarterid)  3 + 1), -2), ‘-01’), 1) as q_end  –季结束日</p>
<p>   – 年</p>
<p>   , d_year</p>
<p>   , y_start</p>
<p>   , y_end</p>
<p>from (</p>
<p>​     select <code>date</code></p>
<p>​       , pmod(datediff(<code>date</code>, ‘2012-01-01’), 7)         as weekid  –获取周几</p>
<p>​       , cast(substr(<code>date</code>, 6, 2) as int)            as monthid  –获取月份</p>
<p>​       , case</p>
<p>​          when cast(substr(<code>date</code>, 6, 2) as int) &lt;= 3 then 1</p>
<p>​          when cast(substr(<code>date</code>, 6, 2) as int) &lt;= 6 then 2</p>
<p>​          when cast(substr(<code>date</code>, 6, 2) as int) &lt;= 9 then 3</p>
<p>​          when cast(substr(<code>date</code>, 6, 2) as int) &lt;= 12 then 4</p>
<p>​       end                            as quarterid –获取季节 可以直接使用 quarter(<code>date</code>)</p>
<p>​       , substr(<code>date</code>, 1, 4)                   as d_year  – 获取年份</p>
<p>​       , trunc(<code>date</code>, ‘YYYY’)                  as y_start  –年开始日</p>
<p>​       , date_sub(trunc(add_months(<code>date</code>, 12), ‘YYYY’), 1) as y_end   –年结束日</p>
<p>​       , date_sub(<code>date</code>, dayofmonth(<code>date</code>) - 1)         as m_start  –当月第一天</p>
<p>​       , last_day(date_sub(<code>date</code>, dayofmonth(<code>date</code>) - 1))     m_end   –当月最后一天</p>
<p>​       , weekofyear(<code>date</code>)                    as d_week  –年内第几周</p>
<p>​     from (</p>
<p>​          – ‘2021-04-01’是开始日期, ‘2022-03-31’是截止日期</p>
<p>​         select date_add(‘2021-04-01’, t0.pos) as <code>date</code></p>
<p>​         from (</p>
<p>​              select posexplode(</p>
<p>​                     split(</p>
<p>​                         repeat(‘o’, datediff(</p>
<p>​                             from_unixtime(unix_timestamp(‘2022-03-31’, ‘yyyy-mm-dd’),</p>
<p>​                                    ‘yyyy-mm-dd’),</p>
<p>​                             ‘2021-04-01’)), ‘o’</p>
<p>​                       )</p>
<p>​                   )</p>
<p>​            ) t0</p>
<p>​       ) t1</p>
<p>   ) t2;</p>
<h2 id="十七、时间序列–构造累积日期"><a href="#十七、时间序列–构造累积日期" class="headerlink" title="十七、时间序列–构造累积日期"></a>十七、时间序列–构造累积日期</h2><p>表名：t17</p>
<p>表字段及内容：</p>
<p>date_id</p>
<p>2017-08-01</p>
<p>2017-08-02</p>
<p>2017-08-03</p>
<h4 id="问题一：每一日期，都扩展成月初至当天"><a href="#问题一：每一日期，都扩展成月初至当天" class="headerlink" title="问题一：每一日期，都扩展成月初至当天"></a>问题一：每一日期，都扩展成月初至当天</h4><p>输出结果如下所示：</p>
<p>date_id  date_to_day</p>
<p>2017-08-01 2017-08-01</p>
<p>2017-08-02 2017-08-01</p>
<p>2017-08-02 2017-08-02</p>
<p>2017-08-03 2017-08-01</p>
<p>2017-08-03 2017-08-02</p>
<p>2017-08-03 2017-08-03</p>
<p>这种累积相关的表，常做桥接表。</p>
<p>参考答案:</p>
<p>select</p>
<p> date_id,</p>
<p> date_add(date_start_id,pos) as date_to_day</p>
<p>from</p>
<p>(</p>
<p> select</p>
<p>  date_id,</p>
<p>  date_sub(date_id,dayofmonth(date_id)-1) as date_start_id</p>
<p> from t17</p>
<p>) m lateral view </p>
<p>posexplode(split(space(datediff(from_unixtime(unix_timestamp(date_id,’yyyy-MM-dd’)),from_unixtime(unix_timestamp(date_start_id,’yyyy-MM-dd’)))), ‘’)) t as pos, val;</p>
<h2 id="十八、时间序列–构造连续日期"><a href="#十八、时间序列–构造连续日期" class="headerlink" title="十八、时间序列–构造连续日期"></a>十八、时间序列–构造连续日期</h2><p>表名：t18</p>
<p>表字段及内容：</p>
<p>a       b     c</p>
<p>101    2018-01-01   10</p>
<p>101    2018-01-03   20</p>
<p>101    2018-01-06   40</p>
<p>102    2018-01-02   20</p>
<p>102    2018-01-04   30</p>
<p>102    2018-01-07   60</p>
<h4 id="问题一：构造连续日期"><a href="#问题一：构造连续日期" class="headerlink" title="问题一：构造连续日期"></a>问题一：构造连续日期</h4><p>问题描述：将表中数据的b字段扩充至范围[2018-01-01, 2018-01-07]，并累积对c求和。</p>
<p>b字段的值是较稀疏的。</p>
<p>输出结果如下所示：</p>
<p>a       b     c   d</p>
<p>101    2018-01-01   10   10</p>
<p>101    2018-01-02   0   10</p>
<p>101    2018-01-03   20   30</p>
<p>101    2018-01-04   0   30</p>
<p>101    2018-01-05   0   30</p>
<p>101    2018-01-06   40   70</p>
<p>101    2018-01-07   0   70</p>
<p>102    2018-01-01   0   0</p>
<p>102    2018-01-02   20   20</p>
<p>102    2018-01-03   0   20</p>
<p>102    2018-01-04   30   50</p>
<p>102    2018-01-05   0   50</p>
<p>102    2018-01-06   0   50</p>
<p>102    2018-01-07   60  110</p>
<p>参考答案:</p>
<p>select</p>
<p> a,</p>
<p> b,</p>
<p> c,</p>
<p> sum(c) over(partition by a order by b) as d</p>
<p>from</p>
<p>(</p>
<p> select</p>
<p> t1.a,</p>
<p> t1.b,</p>
<p> case</p>
<p>  when t18.b is not null then t18.c</p>
<p>  else 0</p>
<p> end as c</p>
<p> from</p>
<p> (</p>
<p>  select</p>
<p>  a,</p>
<p>  date_add(s,pos) as b</p>
<p>  from</p>
<p>  (</p>
<p>   select</p>
<p>​    a, </p>
<p>​    ‘2018-01-01’ as s, </p>
<p>​    ‘2018-01-07’ as r</p>
<p>   from (select a from t18 group by a) ta</p>
<p>  ) m lateral view </p>
<p>   posexplode(split(space(datediff(from_unixtime(unix_timestamp(r,’yyyy-MM-dd’)),from_unixtime(unix_timestamp(s,’yyyy-MM-dd’)))), ‘’)) t as pos, val</p>
<p> ) t1</p>
<p>  left join t18</p>
<p>  on t1.a = t18.a and t1.b = t18.b</p>
<p>) ts;</p>
<h2 id="十九、时间序列–取多个字段最新的值"><a href="#十九、时间序列–取多个字段最新的值" class="headerlink" title="十九、时间序列–取多个字段最新的值"></a>十九、时间序列–取多个字段最新的值</h2><p>表名：t19</p>
<p>表字段及内容：</p>
<p>date_id  a  b  c</p>
<p>2014   AB 12  bc</p>
<p>2015     23  </p>
<p>2016        d</p>
<p>2017   BC </p>
<h4 id="问题一：如何一并取出最新日期"><a href="#问题一：如何一并取出最新日期" class="headerlink" title="问题一：如何一并取出最新日期"></a>问题一：如何一并取出最新日期</h4><p>输出结果如下所示：</p>
<p>date_a  a  date_b  b  date_c  c</p>
<p>2017  BC  2015   23  2016  d</p>
<p>参考答案:</p>
<p>此处给出三种解法，其一：</p>
<p>SELECT max(CASE WHEN rn_a = 1 THEN date_id else 0 END) AS date_a</p>
<p>​    ,max(CASE WHEN rn_a = 1 THEN a else null END) AS a</p>
<p>​    ,max(CASE WHEN rn_b = 1 THEN date_id else 0 END) AS date_b</p>
<p>​    ,max(CASE WHEN rn_b = 1 THEN b else NULL END) AS b</p>
<p>​    ,max(CASE WHEN rn_c = 1 THEN date_id else 0 END) AS date_c</p>
<p>​    ,max(CASE WHEN rn_c = 1 THEN c else null END) AS c</p>
<p>FROM  (</p>
<p>​      SELECT date_id</p>
<p>​          ,a</p>
<p>​          ,b</p>
<p>​          ,c</p>
<p>​          –对每列上不为null的值 的 日期 进行排序</p>
<p>​          ,row_number()OVER( PARTITION BY 1 ORDER BY CASE WHEN a IS NULL THEN 0 ELSE date_id END DESC) AS rn_a</p>
<p>​          ,row_number()OVER(PARTITION BY 1 ORDER BY CASE WHEN b IS NULL THEN 0 ELSE date_id END DESC) AS rn_b</p>
<p>​          ,row_number()OVER(PARTITION BY 1 ORDER BY CASE WHEN c IS NULL THEN 0 ELSE date_id END DESC) AS rn_c</p>
<p>​      FROM  t19</p>
<p>​    ) t</p>
<p>WHERE  t.rn_a = 1</p>
<p>OR   t.rn_b = 1</p>
<p>OR   t.rn_c = 1;</p>
<p>其二：</p>
<p>SELECT </p>
<p>  a.date_id</p>
<p> ,a.a</p>
<p> ,b.date_id</p>
<p> ,b.b</p>
<p> ,c.date_id</p>
<p> ,c.c</p>
<p>FROM</p>
<p>(</p>
<p>  SELECT </p>
<p>   t.date_id,</p>
<p>   t.a</p>
<p>  FROM </p>
<p>  (</p>
<p>   SELECT </p>
<p>​    t.date_id</p>
<p>​    ,t.a</p>
<p>​    ,t.b</p>
<p>​    ,t.c</p>
<p>   FROM t19 t INNER JOIN  t19 t1 ON t.date_id = t1.date_id AND t.a IS NOT NULL</p>
<p>  ) t</p>
<p>  ORDER BY t.date_id DESC</p>
<p>  LIMIT 1</p>
<p>) a</p>
<p>LEFT JOIN </p>
<p>(</p>
<p> SELECT </p>
<p>  t.date_id</p>
<p>  ,t.b</p>
<p> FROM  </p>
<p> (</p>
<p>  SELECT </p>
<p>   t.date_id</p>
<p>   ,t.b</p>
<p>  FROM t19 t INNER JOIN t19 t1 ON t.date_id = t1.date_id AND t.b IS NOT NULL</p>
<p> ) t</p>
<p> ORDER BY t.date_id DESC</p>
<p> LIMIT 1</p>
<p>) b ON 1 = 1 </p>
<p>LEFT JOIN</p>
<p>(</p>
<p> SELECT </p>
<p>  t.date_id</p>
<p>  ,t.c</p>
<p> FROM  </p>
<p> (</p>
<p>  SELECT </p>
<p>   t.date_id</p>
<p>   ,t.c</p>
<p>  FROM t19 t INNER JOIN t19 t1 ON t.date_id = t1.date_id AND t.c IS NOT NULL</p>
<p> ) t</p>
<p> ORDER BY t.date_id DESC</p>
<p> LIMIT  1</p>
<p>) c</p>
<p>ON 1 = 1;</p>
<p>其三：</p>
<p>select </p>
<p>from </p>
<p>(</p>
<p> select t1.date_id as date_a,t1.a from (select t1.date_id,t1.a from t19 t1 where t1.a is not null) t1</p>
<p> inner join (select max(t1.date_id) as date_id  from t19 t1 where t1.a is not null) t2</p>
<p> on t1.date_id=t2.date_id</p>
<p>) t1</p>
<p>cross join</p>
<p>(</p>
<p> select t1.date_b,t1.b from (select t1.date_id as date_b,t1.b from t19 t1 where t1.b is not null) t1</p>
<p> inner join (select max(t1.date_id) as date_id  from t19 t1 where t1.b is not null)t2</p>
<p> on t1.date_b=t2.date_id</p>
<p>) t2</p>
<p>cross join </p>
<p>(</p>
<p> select t1.date_c,t1.c from (select t1.date_id as date_c,t1.c from t19 t1 where t1.c is not null) t1</p>
<p> inner join (select max(t1.date_id) as date_id  from t19 t1 where t1.c is not null)t2</p>
<p> on t1.date_c=t2.date_id</p>
<p>) t3;</p>
<h2 id="二十、时间序列–补全数据"><a href="#二十、时间序列–补全数据" class="headerlink" title="二十、时间序列–补全数据"></a>二十、时间序列–补全数据</h2><p>表名：t20</p>
<p>表字段及内容：</p>
<p>date_id  a  b  c</p>
<p>2014   AB 12  bc</p>
<p>2015     23  </p>
<p>2016        d</p>
<p>2017   BC </p>
<h4 id="问题一：如何使用最新数据补全表格"><a href="#问题一：如何使用最新数据补全表格" class="headerlink" title="问题一：如何使用最新数据补全表格"></a>问题一：如何使用最新数据补全表格</h4><p>输出结果如下所示：</p>
<p>date_id  a  b  c</p>
<p>2014   AB 12  bc</p>
<p>2015   AB 23  bc</p>
<p>2016   AB 23  d</p>
<p>2017   BC 23  d</p>
<p>参考答案:</p>
<p>select </p>
<p> date_id, </p>
<p> first_value(a) over(partition by aa order by date_id) as a,</p>
<p> first_value(b) over(partition by bb order by date_id) as b,</p>
<p> first_value(c) over(partition by cc order by date_id) as c</p>
<p>from</p>
<p>(</p>
<p> select </p>
<p>  date_id,</p>
<p>  a,</p>
<p>  b,</p>
<p>  c,</p>
<p>  count(a) over(order by date_id) as aa,</p>
<p>  count(b) over(order by date_id) as bb,</p>
<p>  count(c) over(order by date_id) as cc</p>
<p> from t20</p>
<p>)tmp1;</p>
<h2 id="二十一、时间序列–取最新完成状态的前一个状态"><a href="#二十一、时间序列–取最新完成状态的前一个状态" class="headerlink" title="二十一、时间序列–取最新完成状态的前一个状态"></a>二十一、时间序列–取最新完成状态的前一个状态</h2><p>表名：t21</p>
<p>表字段及内容：</p>
<p>date_id  a  b</p>
<p>2014   1  A</p>
<p>2015   1  B</p>
<p>2016   1  A</p>
<p>2017   1  B</p>
<p>2013   2  A</p>
<p>2014   2  B</p>
<p>2015   2  A</p>
<p>2014   3  A</p>
<p>2015   3  A</p>
<p>2016   3  B</p>
<p>2017   3  A</p>
<p>上表中B为完成状态。</p>
<h4 id="问题一：取最新完成状态的前一个状态"><a href="#问题一：取最新完成状态的前一个状态" class="headerlink" title="问题一：取最新完成状态的前一个状态"></a>问题一：取最新完成状态的前一个状态</h4><p>输出结果如下所示：</p>
<p>date_id a  b</p>
<p>2016   1  A</p>
<p>2013   2  A</p>
<p>2015   3  A</p>
<p>参考答案:</p>
<p>此处给出两种解法，其一：</p>
<p>select</p>
<p>  t21.date_id,</p>
<p>  t21.a,</p>
<p>  t21.b</p>
<p>from</p>
<p>  (</p>
<p>​    select</p>
<p>​      max(date_id) date_id,</p>
<p>​      a</p>
<p>​    from</p>
<p>​      t21</p>
<p>​    where</p>
<p>​      b = ‘B’</p>
<p>​    group by</p>
<p>​      a</p>
<p>  ) t1</p>
<p>  inner join t21 on t1.date_id -1 = t21.date_id</p>
<p>and t1.a = t21.a;</p>
<p>其二：</p>
<p>select</p>
<p> next_date_id as date_id</p>
<p> ,a</p>
<p> ,next_b as b</p>
<p>from(</p>
<p> select</p>
<p>  ,min(nk) over(partition by a,b) as minb</p>
<p> from(</p>
<p>  select</p>
<p>   ,row_number() over(partition by a order by date_id desc) nk</p>
<p>   ,lead(date_id) over(partition by a order by date_id desc) next_date_id</p>
<p>   ,lead(b) over(partition by a order by date_id desc) next_b</p>
<p>  from(</p>
<p>   select  from t21</p>
<p>  ) t</p>
<p> ) t</p>
<p>) t</p>
<p>where minb = nk and b = ‘B’;</p>
<h4 id="问题二：如何将完成状态的过程合并"><a href="#问题二：如何将完成状态的过程合并" class="headerlink" title="问题二：如何将完成状态的过程合并"></a>问题二：如何将完成状态的过程合并</h4><p>输出结果如下所示:</p>
<p>a  b_merge</p>
<p>1  A、B、A、B</p>
<p>2  A、B</p>
<p>3  A、A、B</p>
<p>参考答案：</p>
<p>select</p>
<p> a</p>
<p> ,collect_list(b) as b</p>
<p>from(</p>
<p> select</p>
<p>  ,min(if(b = ‘B’,nk,null)) over(partition by a) as minb</p>
<p> from(</p>
<p>  select</p>
<p>   ,row_number() over(partition by a order by date_id desc) nk</p>
<p>  from(</p>
<p>   select  from t21</p>
<p>  ) t</p>
<p> ) t</p>
<p>) t</p>
<p>where nk &gt;= minb</p>
<p>group by a;</p>
<h2 id="二十二、非等值连接–范围匹配"><a href="#二十二、非等值连接–范围匹配" class="headerlink" title="二十二、非等值连接–范围匹配"></a>二十二、非等值连接–范围匹配</h2><p>表f是事实表，表d是匹配表，在hive中如何将匹配表中的值关联到事实表中？</p>
<p>表d相当于拉链过的变化维，但日期范围可能是不全的。</p>
<p>表f：</p>
<p>date_id p_id</p>
<p> 2017  C</p>
<p> 2018  B</p>
<p> 2019  A</p>
<p> 2013  C</p>
<p>表d：</p>
<p>d_start  d_end  p_id  p_value</p>
<p> 2016   2018   A    1</p>
<p> 2016   2018   B    2</p>
<p> 2008   2009   C    4</p>
<p> 2010   2015   C    3</p>
<h4 id="问题一：范围匹配"><a href="#问题一：范围匹配" class="headerlink" title="问题一：范围匹配"></a>问题一：范围匹配</h4><p>输出结果如下所示：</p>
<p>date_id p_id  p_value</p>
<p> 2017  C   null</p>
<p> 2018  B   2</p>
<p> 2019  A   null</p>
<p> 2013  C   3</p>
<p>参考答案：</p>
<p>此处给出两种解法，其一：</p>
<p>select </p>
<p> f.date_id,</p>
<p> f.p_id,</p>
<p> A.p_value</p>
<p>from f </p>
<p>left join </p>
<p>(</p>
<p> select </p>
<p>  date_id,</p>
<p>  p_id,</p>
<p>  p_value</p>
<p> from </p>
<p> (</p>
<p>  select </p>
<p>   f.date_id,</p>
<p>   f.p_id,</p>
<p>   d.p_value</p>
<p>  from f </p>
<p>  left join d on f.p_id = d.p_id</p>
<p>  where f.date_id &gt;= d.d_start and f.date_id &lt;= d.d_end</p>
<p> )A</p>
<p>)A</p>
<p>ON f.date_id = A.date_id;</p>
<p>其二：</p>
<p>select </p>
<p>  date_id,</p>
<p>  p_id,</p>
<p>  flag as p_value</p>
<p>from (</p>
<p>  select </p>
<p>​    f.date_id,</p>
<p>​    f.p_id,</p>
<p>​    d.d_start,</p>
<p>​    d.d_end,</p>
<p>​    d.p_value,</p>
<p>​    if(f.date_id between d.d_start and d.d_end,d.p_value,null) flag,</p>
<p>​    max(d.d_end) over(partition by date_id) max_end</p>
<p>  from f</p>
<p>  left join d</p>
<p>  on f.p_id = d.p_id</p>
<p>) tmp</p>
<p>where d_end = max_end;</p>
<h2 id="二十三、非等值连接–最近匹配"><a href="#二十三、非等值连接–最近匹配" class="headerlink" title="二十三、非等值连接–最近匹配"></a>二十三、非等值连接–最近匹配</h2><p>表t23_1和表t23_2通过a和b关联时，有相等的取相等的值匹配，不相等时每一个a的值在b中找差值最小的来匹配。</p>
<p>t23_1和t23_2为两个班的成绩单，t23_1班的每个学生成绩在t23_2班中找出成绩最接近的成绩。</p>
<p>表t23_1：a中无重复值</p>
<p>a</p>
<p>1</p>
<p>2</p>
<p>4</p>
<p>5</p>
<p>8</p>
<p>10</p>
<p>表t23_2：b中无重复值</p>
<p>b</p>
<p>2</p>
<p>3</p>
<p>7</p>
<p>11</p>
<p>13</p>
<h4 id="问题一：单向最近匹配"><a href="#问题一：单向最近匹配" class="headerlink" title="问题一：单向最近匹配"></a>问题一：单向最近匹配</h4><p>输出结果如下所示：</p>
<p>注意：b的值可能会被丢弃</p>
<p>a  b</p>
<p>1  2</p>
<p>2  2</p>
<p>4  3</p>
<p>5  3</p>
<p>5  7</p>
<p>8  7</p>
<p>10  11</p>
<p>参考答案：</p>
<p>select </p>
<p>from</p>
<p>(</p>
<p> select </p>
<p>  ttt1.a,</p>
<p>  ttt1.b </p>
<p> from</p>
<p> (</p>
<p>  select </p>
<p>   tt1.a,</p>
<p>   t23_2.b,</p>
<p>   dense_rank() over(partition by tt1.a order by abs(tt1.a-t23_2.b)) as dr </p>
<p>  from </p>
<p>  (</p>
<p>   select </p>
<p>​    t23_1.a </p>
<p>   from t23_1 </p>
<p>   left join t23_2 on t23_1.a=t23_2.b </p>
<p>   where t23_2.b is null</p>
<p>  ) tt1 </p>
<p>  cross join t23_2</p>
<p> ) ttt1 </p>
<p> where ttt1.dr=1 </p>
<p> union all</p>
<p> select </p>
<p>  t23_1.a,</p>
<p>  t23_2.b </p>
<p> from t23_1 </p>
<p> inner join t23_2 on t23_1.a=t23_2.b</p>
<p>) result_t </p>
<p>order by result_t.a;</p>
<h2 id="二十四、N指标–累计去重"><a href="#二十四、N指标–累计去重" class="headerlink" title="二十四、N指标–累计去重"></a>二十四、N指标–累计去重</h2><p>假设表A为事件流水表，客户当天有一条记录则视为当天活跃。</p>
<p>表A：</p>
<p>  time_id     user_id</p>
<p>2018-01-01 10:00:00  001</p>
<p>2018-01-01 11:03:00  002</p>
<p>2018-01-01 13:18:00  001</p>
<p>2018-01-02 08:34:00  004</p>
<p>2018-01-02 10:08:00  002</p>
<p>2018-01-02 10:40:00  003</p>
<p>2018-01-02 14:21:00  002</p>
<p>2018-01-02 15:39:00  004</p>
<p>2018-01-03 08:34:00  005</p>
<p>2018-01-03 10:08:00  003</p>
<p>2018-01-03 10:40:00  001</p>
<p>2018-01-03 14:21:00  005</p>
<p>假设客户活跃非常，一天产生的事件记录平均达千条。</p>
<h4 id="问题一：累计去重"><a href="#问题一：累计去重" class="headerlink" title="问题一：累计去重"></a>问题一：累计去重</h4><p>输出结果如下所示：</p>
<p>日期    当日活跃人数   月累计活跃人数_截至当日</p>
<p>date_id  user_cnt_act  user_cnt_act_month</p>
<p>2018-01-01   2        2</p>
<p>2018-01-02   3        4</p>
<p>2018-01-03   3        5</p>
<p>参考答案：</p>
<p>SELECT tt1.date_id</p>
<p>​    ,tt2.user_cnt_act</p>
<p>​    ,tt1.user_cnt_act_month</p>
<p>FROM</p>
<p>(  – ④ 按照t.date_id分组求出user_cnt_act_month，得到tt1</p>
<p> SELECT t.date_id</p>
<p>​    ,COUNT(user_id) AS user_cnt_act_month</p>
<p> FROM</p>
<p> (  – ③ 表a和表b进行笛卡尔积，按照a.date_id,b.user_id分组，保证截止到当日的用户唯一，得出表t。</p>
<p> SELECT a.date_id</p>
<p>​     ,b.user_id</p>
<p> FROM</p>
<p> (  – ① 按照日期分组，取出date_id字段当主表的维度字段 得出表a</p>
<p>  SELECT from_unixtime(unix_timestamp(time_id),’yyyy-MM-dd’) AS date_id</p>
<p>  FROM test.temp_tanhaidi_20211213_1</p>
<p>  GROUP BY from_unixtime(unix_timestamp(time_id),’yyyy-MM-dd’)</p>
<p> ) a</p>
<p> INNER JOIN</p>
<p> (  – ② 按照date_id、user_id分组，保证每天每个用户只有一条记录，得出表b</p>
<p>  SELECT from_unixtime(unix_timestamp(time_id),’yyyy-MM-dd’) AS date_id</p>
<p>​     ,user_id</p>
<p>  FROM test.temp_tanhaidi_20211213_1</p>
<p>  GROUP BY from_unixtime(unix_timestamp(time_id),’yyyy-MM-dd’)</p>
<p>​      ,user_id</p>
<p> ) b</p>
<p> ON 1 = 1</p>
<p> WHERE a.date_id &gt;= b.date_id</p>
<p> GROUP BY a.date_id</p>
<p>​      ,b.user_id</p>
<p> ) t</p>
<p> GROUP BY t.date_id</p>
<p>) tt1</p>
<p>LEFT JOIN</p>
<p>(  – ⑥ 按照date_id分组求出user_cnt_act，得到tt2</p>
<p> SELECT date_id</p>
<p>​    ,COUNT(user_id) AS user_cnt_act</p>
<p> FROM</p>
<p> (  – ⑤ 按照日期分组，取出date_id字段当主表的维度字段 得出表a</p>
<p> SELECT from_unixtime(unix_timestamp(time_id),’yyyy-MM-dd’) AS date_id</p>
<p>​     ,user_id</p>
<p> FROM test.temp_tanhaidi_20211213_1</p>
<p> GROUP BY from_unixtime(unix_timestamp(time_id),’yyyy-MM-dd’)</p>
<p>​      ,user_id</p>
<p> ) a</p>
<p> GROUP BY date_id</p>
<p>) tt2</p>
<p>ON tt2.date_id = tt1.date_id</p>
]]></content>
      <categories>
        <category>BigData</category>
        <category>HQL练习</category>
      </categories>
      <tags>
        <tag>HQL练习</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据常用命令</title>
    <url>/2021/12/23/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Linux（vi-vim）"><a href="#Linux（vi-vim）" class="headerlink" title="Linux（vi/vim）"></a>Linux（vi/vim）</h2><h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><table>
<thead>
<tr>
<th>语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制光标当前一行</td>
</tr>
<tr>
<td>y数字y</td>
<td>复制一段（从第几行到第几行）</td>
</tr>
<tr>
<td>p</td>
<td>箭头移动到目的行粘贴</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标当前行</td>
</tr>
<tr>
<td>d数字d</td>
<td>删除光标（含）后多少行</td>
</tr>
<tr>
<td>x</td>
<td>删除一个字母，相当于del</td>
</tr>
<tr>
<td>X</td>
<td>删除一个字母，相当于Backspace</td>
</tr>
<tr>
<td>yw</td>
<td>复制一个词</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个词</td>
</tr>
<tr>
<td>shift+^</td>
<td>移动到行头</td>
</tr>
<tr>
<td>shift+$</td>
<td>移动到行尾</td>
</tr>
<tr>
<td>1+shift+g</td>
<td>移动到页头，数字</td>
</tr>
<tr>
<td>shift+g</td>
<td>移动到页尾</td>
</tr>
<tr>
<td>数字N+shift+g</td>
<td>移动到目标行</td>
</tr>
</tbody></table>
<h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>当前光标前</td>
</tr>
<tr>
<td>a</td>
<td>当前光标后</td>
</tr>
<tr>
<td>o</td>
<td>当前光标行的下一行</td>
</tr>
<tr>
<td>I</td>
<td>光标所在行最前</td>
</tr>
<tr>
<td>A</td>
<td>光标所在行最后</td>
</tr>
<tr>
<td>O</td>
<td>当前光标行的上一行</td>
</tr>
</tbody></table>
<h3 id="指令模式"><a href="#指令模式" class="headerlink" title="指令模式"></a>指令模式</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:!</td>
<td>强制执行</td>
</tr>
<tr>
<td>/要查找的词</td>
<td>n 查找下一个，N 往上查找</td>
</tr>
<tr>
<td>? 要查找的词</td>
<td>n是查找上一个，shift+n是往下查找</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>关闭行号</td>
</tr>
</tbody></table>
<h3 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h3><h4 id="gzip-gunzip-压缩"><a href="#gzip-gunzip-压缩" class="headerlink" title="gzip/gunzip 压缩"></a>gzip/gunzip 压缩</h4><p>（1）只能压缩文件不能压缩目录</p>
<p>（2）不保留原来的文件</p>
<p>gzip压缩：gzip hello.txt</p>
<p>gunzip解压缩文件：gunzip hello.txt.gz</p>
<h4 id="zip-unzip-压缩"><a href="#zip-unzip-压缩" class="headerlink" title="zip/unzip 压缩"></a>zip/unzip 压缩</h4><p>可以压缩目录且保留源文件</p>
<p>zip压缩（压缩 1.txt 和2.txt，压缩后的名称为mypackage.zip）：zip hello.zip hello.txt world.txt</p>
<p>unzip解压：unzip hello.zip</p>
<p>unzip解压到指定目录：unzip hello.zip -d /opt</p>
<h4 id="tar-打包"><a href="#tar-打包" class="headerlink" title="tar 打包"></a>tar 打包</h4><p>tar压缩多个文件：tar -zcvf hello.txt world.txt</p>
<p>tar压缩目录：tar -zcvf hello.tar.gz opt/</p>
<p>tar解压到当前目录：tar -zxvf hello.tar.gz</p>
<p>tar解压到指定目录：tar -zxvf hello.tar.gz -C /opt</p>
<h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><p>RPM查询命令：rpm -qa |grep firefox</p>
<p>RPM卸载命令：</p>
<p>rpm -e xxxxxx</p>
<p>rpm -e –nodeps xxxxxx（不检查依赖）</p>
<p>RPM安装命令：</p>
<p>rpm -ivh xxxxxx.rpm</p>
<p>rpm -ivh –nodeps fxxxxxx.rpm（–nodeps，不检测依赖进度）</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>-i=install，安装</td>
</tr>
<tr>
<td>-v</td>
<td>-v=verbose，显示详细信息</td>
</tr>
<tr>
<td>-h</td>
<td>-h=hash，进度条</td>
</tr>
<tr>
<td>–nodeps</td>
<td>–nodeps，不检测依赖进度</td>
</tr>
</tbody></table>
<hr>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>command &gt; file</td>
<td>将输出重定向到 file</td>
</tr>
<tr>
<td>command &lt; file</td>
<td>将输入重定向到 file</td>
</tr>
<tr>
<td>command &gt;&gt; file</td>
<td>将输出以追加的方式重定向到 file</td>
</tr>
<tr>
<td>n &gt; file</td>
<td>将文件描述符为 n 的文件重定向到 file</td>
</tr>
<tr>
<td>n &gt;&gt; file</td>
<td>将文件描述符为 n 的文件以追加的方式重定向到 file</td>
</tr>
<tr>
<td>n &gt;&amp; m</td>
<td>将输出文件 m 和 n 合并</td>
</tr>
<tr>
<td>n &lt;&amp; m</td>
<td>将输入文件 m 和 n 合并</td>
</tr>
<tr>
<td>&lt;&lt; tag</td>
<td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody></table>
<h3 id="脚本编辑"><a href="#脚本编辑" class="headerlink" title="脚本编辑"></a>脚本编辑</h3><table>
<thead>
<tr>
<th>快捷方式</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>shift</td>
<td>参数左移</td>
</tr>
<tr>
<td>$@</td>
<td>所有的参数</td>
</tr>
<tr>
<td>$#</td>
<td>参数的个数</td>
</tr>
</tbody></table>
<hr>
<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h3 id="启动类命令"><a href="#启动类命令" class="headerlink" title="启动类命令"></a>启动类命令</h3><table>
<thead>
<tr>
<th>功能说明</th>
<th>命令脚本</th>
</tr>
</thead>
<tbody><tr>
<td>启动hdfs集群</td>
<td>sbin/start-dfs.sh</td>
</tr>
<tr>
<td>启动yarn</td>
<td>sbin/start-yarn.sh</td>
</tr>
</tbody></table>
<h3 id="hadoop-fs-hdfs-dfs-命令"><a href="#hadoop-fs-hdfs-dfs-命令" class="headerlink" title="hadoop fs/hdfs dfs 命令"></a>hadoop fs/hdfs dfs 命令</h3><table>
<thead>
<tr>
<th>功能说明</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>创建目录</td>
<td>hdfs dfs -mkdir -p /data/flink</td>
</tr>
<tr>
<td>显示目录</td>
<td>hdfs dfs -ls /</td>
</tr>
<tr>
<td>从HDFS拷贝到本地</td>
<td>hdfs dfs -copyToLocal /data/data.txt ./</td>
</tr>
<tr>
<td>文件上传到集群(从本地)</td>
<td>hhdfs dfs -copyFromLocal data.txt /</td>
</tr>
<tr>
<td>文件下载</td>
<td>hdfs dfs -get /data/flink</td>
</tr>
<tr>
<td>删除集群的文件</td>
<td>hdfs dfs -rm /data/flink</td>
</tr>
<tr>
<td>删除文件夹</td>
<td>hdfs dfs -rm -r -skipTrash /data</td>
</tr>
<tr>
<td>从本地剪切粘贴到HDFS</td>
<td>hdfs dfs  -moveFromLocal data.txt /data/</td>
</tr>
<tr>
<td>追加一个文件到已经存在的文件末尾hdfs dfs -appendToFile data1.txt /data/data.txt</td>
<td></td>
</tr>
<tr>
<td>显示文件内容</td>
<td>hdfs dfs -cat data.txt</td>
</tr>
<tr>
<td>修改文件所属权限</td>
<td>hdfs dfs  -chmod  777 xxx.sh</td>
</tr>
<tr>
<td>修改文件所属用户组</td>
<td>hdfs dfs  -chown  root:root data.txt</td>
</tr>
<tr>
<td>从HDFS的一个路径拷贝到HDFS的另一个路径</td>
<td>hdfs dfs -cp data.txt /data1.txt</td>
</tr>
<tr>
<td>在HDFS目录中移动文件</td>
<td>hdfs dfs -mv data.txt /opt/</td>
</tr>
<tr>
<td>合并下载多个文件</td>
<td>hdfs dfs  -getmerge /data/* ./data_merge.txt</td>
</tr>
<tr>
<td>hadoop fs -put</td>
<td>等同于copyFromLocal</td>
</tr>
<tr>
<td>显示一个文件的末尾</td>
<td>hdfs dfs -tail data.txt</td>
</tr>
<tr>
<td>删除文件或文件夹</td>
<td>hdfs dfs -rm /data/data.txt</td>
</tr>
<tr>
<td>删除空目录</td>
<td>hdfs dfs -rmdir /data</td>
</tr>
<tr>
<td>统计文件夹的大小信息</td>
<td>hdfs dfs -s -h /data</td>
</tr>
<tr>
<td>统计文件夹下的文件大小信息</td>
<td>hdfs dfs  -h /data</td>
</tr>
<tr>
<td>设置HDFS中文件的副本数量</td>
<td>hdfs dfs -setrep 3 /data/data.txt</td>
</tr>
</tbody></table>
<h3 id="yarn命令"><a href="#yarn命令" class="headerlink" title="yarn命令"></a>yarn命令</h3><table>
<thead>
<tr>
<th>功能说明</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>查看正在运行的yarn任务列表</td>
<td>yarn application -list appID</td>
</tr>
<tr>
<td>kill掉指定id的yarn任务</td>
<td>yarn application -kill appID</td>
</tr>
<tr>
<td>查看任务日志信息</td>
<td>yarn logs -applicationId appID</td>
</tr>
</tbody></table>
<hr>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><table>
<thead>
<tr>
<th>功能说明</th>
<th>命令脚本</th>
</tr>
</thead>
<tbody><tr>
<td>启动zookeeper服务</td>
<td>zkServer.sh start</td>
</tr>
<tr>
<td>查看zookeeper状态</td>
<td>zkServer.sh status</td>
</tr>
<tr>
<td>停止zookeeper服务</td>
<td>zkServer.sh stop</td>
</tr>
<tr>
<td>启动zookeeper客户端</td>
<td>zkCli.sh -server 127.0.0.1:2181</td>
</tr>
<tr>
<td>退出zookeeper客户端</td>
<td>quit</td>
</tr>
</tbody></table>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><table>
<thead>
<tr>
<th>功能说明</th>
<th>命令脚本</th>
</tr>
</thead>
<tbody><tr>
<td>当前znode中所包含的内容</td>
<td>ls /</td>
</tr>
<tr>
<td>创建普通节点(前面是节点的路径，后面是值）</td>
<td>create /bigdata/flink “flink”</td>
</tr>
<tr>
<td>获取节点的值</td>
<td>get /bigdata</td>
</tr>
<tr>
<td>修改节点的值</td>
<td>set /bigdata/flink “flinksql”</td>
</tr>
<tr>
<td>删除节点</td>
<td>delete /bigdata/flink</td>
</tr>
<tr>
<td>递归删除节点</td>
<td>rmr /bigdata</td>
</tr>
</tbody></table>
<h3 id="四字母命令"><a href="#四字母命令" class="headerlink" title="四字母命令"></a>四字母命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>conf</td>
<td>zk服务配置的详细信息</td>
<td>echo conf | nc 127.0.0.1 2181</td>
</tr>
<tr>
<td>stat</td>
<td>客户端与zk连接的简要信息</td>
<td>参考上面</td>
</tr>
<tr>
<td>srvr</td>
<td>zk服务的详细信息</td>
<td>参考上面</td>
</tr>
<tr>
<td>cons</td>
<td>客户端与zk连接的详细信息</td>
<td>参考上面</td>
</tr>
<tr>
<td>mntr</td>
<td>zk服务目前的性能状况</td>
<td>参考上面</td>
</tr>
<tr>
<td>crst</td>
<td>重置当前的所有连接、会话</td>
<td>参考上面</td>
</tr>
<tr>
<td>dump</td>
<td>列出未经处理的会话和连接信息</td>
<td>参考上面</td>
</tr>
<tr>
<td>envi</td>
<td>列出zk的版本信息、主机名称、Java版本、服务器名称等等</td>
<td>参考上面</td>
</tr>
<tr>
<td>ruok</td>
<td>测试服务器是否正在运行，如果在运行返回imok，否则返回空</td>
<td>参考上面</td>
</tr>
<tr>
<td>srst</td>
<td>重置Zookeeper的所有统计信息</td>
<td>参考上面</td>
</tr>
<tr>
<td>wchs</td>
<td>列出watch的总数，连接数</td>
<td>参考上面</td>
</tr>
<tr>
<td>wchp</td>
<td>列出所有watch的路径及sessionID</td>
<td>参考上面</td>
</tr>
<tr>
<td>mntr</td>
<td>列出集群的关键性能数据，包括zk的版本、node数量、临时节点数等等</td>
<td>参考上面</td>
</tr>
</tbody></table>
<hr>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p><strong>注:</strong> 这里机器我只写一个。命令你们也可使用 ./bin/xx.sh (如：./bin/kafka-topics.sh) </p>
<h3 id="查看当前服务器中的所有topic"><a href="#查看当前服务器中的所有topic" class="headerlink" title="查看当前服务器中的所有topic"></a>查看当前服务器中的所有topic</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-topics --zookeeper xxxxxx:2181 --list --exclude-internal </span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">exclude-internal：排除kafka内部topic</span><br><span class="line"></span><br><span class="line">比如： --exclude-internal  --topic &quot;test_.*&quot;</span><br></pre></td></tr></table></figure>

<h3 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-topics --zookeeper xxxxxx:2181  --create </span><br><span class="line">--replication-factor </span><br><span class="line">--partitions 1 </span><br><span class="line">--topic topic_name</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">--topic 定义topic名</span><br><span class="line"></span><br><span class="line">--replication-factor  定义副本数</span><br><span class="line"></span><br><span class="line">--partitions  定义分区数</span><br></pre></td></tr></table></figure>

<h3 id="删除topic"><a href="#删除topic" class="headerlink" title="删除topic"></a>删除topic</h3><p><strong>注意:</strong> 需要server.properties中设置delete.topic.enable=true否则只是标记删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-topics --zookeeper xxxxxx:2181 --delete --topic topic_name</span><br></pre></td></tr></table></figure>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-console-producer --broker-list xxxxxx:9092 --topic topic_name</span><br><span class="line"></span><br><span class="line">可加：--property parse.key=true（有key消息）</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server xxxxxx:9092 --topic topic_name</span><br><span class="line"></span><br><span class="line">注：可选</span><br><span class="line"></span><br><span class="line">--from-beginning：会把主题中以往所有的数据都读取出来</span><br><span class="line"></span><br><span class="line">--whitelist &#x27;.*&#x27; ：消费所有的topic</span><br><span class="line"></span><br><span class="line">--property print.key=true：显示key进行消费</span><br><span class="line"></span><br><span class="line">--partition 0：指定分区消费</span><br><span class="line"></span><br><span class="line">--offset：指定起始偏移量消费</span><br></pre></td></tr></table></figure>

<h3 id="查看某个Topic的详情"><a href="#查看某个Topic的详情" class="headerlink" title="查看某个Topic的详情"></a>查看某个Topic的详情</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-topics --zookeeper xxxxxx:2181 --describe --topic topic_name</span><br></pre></td></tr></table></figure>

<h3 id="修改分区数"><a href="#修改分区数" class="headerlink" title="修改分区数"></a>修改分区数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-topics --zookeeper xxxxxx:2181 --alter --topic topic_name --partitions 6</span><br></pre></td></tr></table></figure>

<h3 id="查看某个消费者组信息"><a href="#查看某个消费者组信息" class="headerlink" title="查看某个消费者组信息"></a>查看某个消费者组信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-consumer-groups --bootstrap-server  xxxxxx:9092  --describe --group group_name </span><br></pre></td></tr></table></figure>

<h3 id="删除消费者组"><a href="#删除消费者组" class="headerlink" title="删除消费者组"></a>删除消费者组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-consumer-groups --bootstrap-server  xxxxxx:9092  ---delete --group group_name </span><br></pre></td></tr></table></figure>

<h3 id="重置offset"><a href="#重置offset" class="headerlink" title="重置offset"></a>重置offset</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-consumer-groups --bootstrap-server  xxxxxx:9092  --group group_name--reset-offsets --all-topics --to-latest --execute </span><br></pre></td></tr></table></figure>

<h3 id="leader重新选举"><a href="#leader重新选举" class="headerlink" title="leader重新选举"></a>leader重新选举</h3><p>指定Topic指定分区用重新PREFERRED：优先副本策略 进行Leader重选举</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-leader-election --bootstrap-server xxxxxx:9092 --topic topic_name --election-type PREFERRED --partition 0</span><br></pre></td></tr></table></figure>

<p>所有Topic所有分区用重新PREFERRED：优先副本策略 进行Leader重选举</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-leader-election --bootstrap-server xxxxxx:9092 --election-type preferred  --all-topic-partitions</span><br></pre></td></tr></table></figure>

<h3 id="查询kafka版本信息"><a href="#查询kafka版本信息" class="headerlink" title="查询kafka版本信息"></a>查询kafka版本信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-configs --bootstrap-server xxxxxx:9092--describe --version</span><br></pre></td></tr></table></figure>

<h3 id="增删改配置"><a href="#增删改配置" class="headerlink" title="增删改配置"></a>增删改配置</h3><table>
<thead>
<tr>
<th>功能说明</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>选择类型</td>
<td>–entity-type (topics/clients/users/brokers/broker- loggers)</td>
</tr>
<tr>
<td>类型名称</td>
<td>–entity-name</td>
</tr>
<tr>
<td>删除配置</td>
<td>–delete-config k1=v1,k2=v2</td>
</tr>
<tr>
<td>添加/修改配置</td>
<td>–add-config k1,k2</td>
</tr>
</tbody></table>
<p>topic添加/修改动态配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-configs --bootstrap-server xxxxxx:9092--alter --entity-type topics --entity-name topic_name --add-config file.delete.delay.ms=222222,retention.ms=999999</span><br></pre></td></tr></table></figure>

<p>topic删除动态配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-configs --bootstrap-server xxxxxx:9092 --alter --entity-type topics --entity-name topic_name --delete-config file.delete.delay.ms,retention.ms</span><br></pre></td></tr></table></figure>

<h3 id="持续批量拉取消息"><a href="#持续批量拉取消息" class="headerlink" title="持续批量拉取消息"></a>持续批量拉取消息</h3><p>单次最大消费10条消息(不加参数意为持续消费)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-verifiable-consumer --bootstrap-server xxxxxx:9092 --group group_name--topic topic_name --max-messages 10</span><br></pre></td></tr></table></figure>

<h3 id="删除指定分区的消息"><a href="#删除指定分区的消息" class="headerlink" title="删除指定分区的消息"></a>删除指定分区的消息</h3><p>删除指定topic的某个分区的消息删除至offset为1024</p>
<p>json文件offset-json-file.json</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;    &quot;partitions&quot;: [        &#123;            &quot;topic&quot;: &quot;topic_name&quot;,            &quot;partition&quot;: 0,            &quot;offset&quot;: 1024        &#125;    ],    &quot;version&quot;: 1&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-delete-records --bootstrap-server xxxxxx:9092 --offset-json-file offset-json-file.json</span><br></pre></td></tr></table></figure>

<h3 id="查看Broker磁盘信息"><a href="#查看Broker磁盘信息" class="headerlink" title="查看Broker磁盘信息"></a>查看Broker磁盘信息</h3><p>查询指定topic磁盘信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-log-dirs --bootstrap-server xxxxxx:9090 --describe --topic-list topic1,topic2</span><br></pre></td></tr></table></figure>

<p>查询指定Broker磁盘信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-log-dirs --bootstrap-server xxxxxx:9090 --describe --topic-list topic1 --broker-list 0</span><br></pre></td></tr></table></figure>

<h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><table>
<thead>
<tr>
<th>功能说明</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>启动hiveserver2服务</td>
<td>bin/hiveserver2</td>
</tr>
<tr>
<td>启动beeline</td>
<td>bin/beeline</td>
</tr>
<tr>
<td>连接hiveserver2</td>
<td>beeline&gt; !connect jdbc:hive2://hadoop102:10000</td>
</tr>
<tr>
<td>metastroe服务</td>
<td>bin/hive –service metastore</td>
</tr>
</tbody></table>
<p>hive 启动元数据服务（metastore和hiveserver2）和优雅关闭脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动： hive.sh start关闭： hive.sh stop重启： hive.sh restart状态： hive.sh status</span><br></pre></td></tr></table></figure>

<p>脚本如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bashHIVE_LOG_DIR=$HIVE_HOME/logsmkdir -p $HIVE_LOG_DIR#检查进程是否运行正常，参数1为进程名，参数2为进程端口function check_process()&#123;    pid=$(ps -ef 2&gt;/dev/null | grep -v grep | grep -i $1 | awk &#x27;&#123;print $2&#125;&#x27;)    ppid=$(netstat -nltp 2&gt;/dev/null | grep $2 | awk &#x27;&#123;print $7&#125;&#x27; | cut -d &#x27;/&#x27; -f 1)    echo $pid    [[ &quot;$pid&quot; =~ &quot;$ppid&quot; ]] &amp;&amp; [ &quot;$ppid&quot; ] &amp;&amp; return 0 || return 1&#125;function hive_start()&#123;    metapid=$(check_process HiveMetastore 9083)    cmd=&quot;nohup hive --service metastore &gt;$HIVE_LOG_DIR/metastore.log 2&gt;&amp;1 &amp;&quot;    cmd=$cmd&quot; sleep4; hdfs dfsadmin -safemode wait &gt;/dev/null 2&gt;&amp;1&quot;    [ -z &quot;$metapid&quot; ] &amp;&amp; eval $cmd || echo &quot;Metastroe服务已启动&quot;    server2pid=$(check_process HiveServer2 10000)    cmd=&quot;nohup hive --service hiveserver2 &gt;$HIVE_LOG_DIR/hiveServer2.log 2&gt;&amp;1 &amp;&quot;    [ -z &quot;$server2pid&quot; ] &amp;&amp; eval $cmd || echo &quot;HiveServer2服务已启动&quot;&#125;function hive_stop()&#123;    metapid=$(check_process HiveMetastore 9083)    [ &quot;$metapid&quot; ] &amp;&amp; kill $metapid || echo &quot;Metastore服务未启动&quot;    server2pid=$(check_process HiveServer2 10000)    [ &quot;$server2pid&quot; ] &amp;&amp; kill $server2pid || echo &quot;HiveServer2服务未启动&quot;&#125;case $1 in&quot;start&quot;)    hive_start    ;;&quot;stop&quot;)    hive_stop    ;;&quot;restart&quot;)    hive_stop    sleep 2    hive_start    ;;&quot;status&quot;)    check_process HiveMetastore 9083 &gt;/dev/null &amp;&amp; echo &quot;Metastore服务运行正常&quot; || echo &quot;Metastore服务运行异常&quot;    check_process HiveServer2 10000 &gt;/dev/null &amp;&amp; echo &quot;HiveServer2服务运行正常&quot; || echo &quot;HiveServer2服务运行异常&quot;    ;;*)    echo Invalid Args!    echo &#x27;Usage: &#x27;$(basename $0)&#x27; start|stop|restart|status&#x27;    ;;esac</span><br></pre></td></tr></table></figure>

<h3 id="常用交互命令"><a href="#常用交互命令" class="headerlink" title="常用交互命令"></a>常用交互命令</h3><table>
<thead>
<tr>
<th>功能说明</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>不进入hive的交互窗口执行sql</td>
<td>bin/hive -e “sql语句”</td>
</tr>
<tr>
<td>执行脚本中sql语句</td>
<td>bin/hive -f hive.sql</td>
</tr>
<tr>
<td>退出hive窗口</td>
<td>exit 或 quit</td>
</tr>
<tr>
<td>命令窗口中查看hdfs文件系统</td>
<td>dfs -ls /</td>
</tr>
<tr>
<td>命令窗口中查看hdfs文件系统</td>
<td>! ls /data/h</td>
</tr>
</tbody></table>
<h3 id="SQL类-特殊的"><a href="#SQL类-特殊的" class="headerlink" title="SQL类(特殊的)"></a>SQL类(特殊的)</h3><table>
<thead>
<tr>
<th>说明</th>
<th>语句</th>
</tr>
</thead>
<tbody><tr>
<td>查看hive中的所有数据库</td>
<td>show databases</td>
</tr>
<tr>
<td>用default数据库</td>
<td>use default</td>
</tr>
<tr>
<td>查询表结构</td>
<td>desc table_name</td>
</tr>
<tr>
<td>查看数据库</td>
<td>show databases</td>
</tr>
<tr>
<td>重命名表名</td>
<td>alter table table1 rename to table2</td>
</tr>
<tr>
<td>修改表中字段</td>
<td>alter table table_name change name user_name String</td>
</tr>
<tr>
<td>修改字段类型</td>
<td>alter table table_name change salary salary Double</td>
</tr>
<tr>
<td>创建外部表</td>
<td>create external table ….</td>
</tr>
<tr>
<td>查询外部表信息</td>
<td>desc formatted outsidetable</td>
</tr>
<tr>
<td>创建视图</td>
<td>create view view_name as select * from table_name …..</td>
</tr>
<tr>
<td>添加数据</td>
<td>load data local inpath ‘xxx’  overwrite into table table_name partition(day=’2021-12-01’)</td>
</tr>
</tbody></table>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>（1） NVL</p>
<p>给值为NULL的数据赋值，它的格式是NVL( value，default_value)。它的功能是如果value为NULL，则NVL函数返回default_value的值，否则返回value的值，如果两个参数都为NULL ，则返回NULL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select nvl(column, 0) from xxx；</span><br></pre></td></tr></table></figure>

<p>（2）行转列</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(string A/col, string B/col…)</td>
<td>返回输入字符串连接后的结果，支持任意个输入字符串</td>
</tr>
<tr>
<td>CONCAT_WS(separator, str1, str2,…)</td>
<td>第一个参数参数间的分隔符，如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间。</td>
</tr>
<tr>
<td>COLLECT_SET(col)</td>
<td>将某字段的值进行去重汇总，产生array类型字段</td>
</tr>
<tr>
<td>COLLECT_LIST(col)</td>
<td>函数只接受基本数据类型，它的主要作用是将某字段的值进行不去重汇总，产生array类型字段。</td>
</tr>
</tbody></table>
<p>（3）列转行(一列转多行)</p>
<p><strong>Split(str, separator)：</strong> 将字符串按照后面的分隔符切割，转换成字符array。</p>
<p><strong>EXPLODE(col)：</strong><br>将hive一列中复杂的array或者map结构拆分成多行。</p>
<p><strong>LATERAL VIEW</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias</span><br></pre></td></tr></table></figure>

<p>解释：lateral view用于和split, explode等UDTF一起使用，它能够将一行数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。</p>
<p>lateral view首先为原始表的每行调用UDTF，UDTF会把一行拆分成一或者多行，lateral view再把结果组合，产生一个支持别名表的虚拟表。</p>
<p><strong>准备数据源测试</strong></p>
<table>
<thead>
<tr>
<th>movie</th>
<th>category</th>
</tr>
</thead>
<tbody><tr>
<td>《功勋》</td>
<td>记录,剧情</td>
</tr>
<tr>
<td>《战狼2》</td>
<td>战争,动作,灾难</td>
</tr>
</tbody></table>
<p><strong>SQL</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT movie,category_name FROM movie_info lateral VIEWexplode(split(category,&quot;,&quot;)) movie_info_tmp  AS category_name ;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">《功勋》      记录《功勋》      剧情《战狼2》     战争《战狼2》     动作《战狼2》     灾难</span><br></pre></td></tr></table></figure>

<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>（1）OVER()</p>
<p>定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化。</p>
<p>（2）CURRENT ROW（当前行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n PRECEDING：往前n行数据n FOLLOWING：往后n行数据</span><br></pre></td></tr></table></figure>

<p>（3）UNBOUNDED（无边界）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNBOUNDED PRECEDING 前无边界，表示从前面的起点UNBOUNDED FOLLOWING后无边界，表示到后面的终点</span><br></pre></td></tr></table></figure>

<p><strong>SQL案例：由起点到当前行的聚合</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select     sum(money) over(partition by user_id order by pay_time rows between UNBOUNDED PRECEDING and current row) from or_order;</span><br></pre></td></tr></table></figure>

<p><strong>SQL案例：当前行和前面一行做聚合</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select     sum(money) over(partition by user_id order by pay_time rows between 1 PRECEDING and current row) from or_order;</span><br></pre></td></tr></table></figure>

<p><strong>SQL案例：当前行和前面一行和后一行做聚合</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select     sum(money) over(partition by user_id order by pay_time rows between 1 PRECEDING AND 1 FOLLOWING )from or_order;</span><br></pre></td></tr></table></figure>

<p><strong>SQL案例：当前行及后面所有行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select     sum(money) over(partition by user_id order by pay_time rows between current row and UNBOUNDED FOLLOWING  )from or_order;</span><br></pre></td></tr></table></figure>

<p>（4）LAG(col,n,default_val)</p>
<p>往前第n行数据，没有的话default_val</p>
<p>（5）LEAD(col,n, default_val)</p>
<p>往后第n行数据，没有的话default_val</p>
<p><strong>SQL案例：查询用户购买明细以及上次的购买时间和下次购买时间</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 	user_id,,pay_time,money,		lag(pay_time,1,&#x27;1970-01-01&#x27;) over(PARTITION by name order by pay_time) prev_time,		lead(pay_time,1,&#x27;1970-01-01&#x27;) over(PARTITION by name order by pay_time) next_timefrom or_order;</span><br></pre></td></tr></table></figure>

<p>（6）FIRST_VALUE(col,true/false)</p>
<p>当前窗口下的第一个值，第二个参数为true，跳过空值。</p>
<p>（7）LAST_VALUE (col,true/false)</p>
<p>当前窗口下的最后一个值，第二个参数为true，跳过空值。</p>
<p><strong>SQL案例：查询用户每个月第一次的购买时间 和 每个月的最后一次购买时间</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select	FIRST_VALUE(pay_time) 	    over(	        partition by user_id,month(pay_time) order by pay_time 	        rows between UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING	        ) first_time,		LAST_VALUE(pay_time) 	    over(partition by user_id,month(pay_time) order by pay_time rows between UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING	    ) last_timefrom or_order;</span><br></pre></td></tr></table></figure>


<p>（8）NTILE(n)</p>
<p>把有序窗口的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。（用于将分组数据按照顺序切分成n片，返回当前切片值）</p>
<p><strong>SQL案例：查询前25%时间的订单信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from (    select User_id,pay_time,money,        ntile(4) over(order by pay_time) sorted        from or_order) twhere sorted = 1;</span><br></pre></td></tr></table></figure>

<h3 id="4个By"><a href="#4个By" class="headerlink" title="4个By"></a>4个By</h3><p>（1）Order By</p>
<p>全局排序，只有一个Reducer。</p>
<p>（2）Sort By</p>
<p>分区内有序。</p>
<p>（3）Distrbute By</p>
<p>类似MR中Partition，进行分区，结合sort by使用。</p>
<p>（4） Cluster By</p>
<p>当Distribute by和Sorts by字段相同时，可以使用Cluster by方式。Cluster by除了具有Distribute by的功能外还兼具Sort by的功能。但是排序只能是升序排序，不能指定排序规则为ASC或者DESC。</p>
<p>在生产环境中Order By用的比较少，容易导致OOM。</p>
<p>在生产环境中Sort By+ Distrbute By用的多。</p>
<h3 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h3><p>（1）RANK() </p>
<p>排序相同时会重复，总数不会变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11335</span><br></pre></td></tr></table></figure>

<p>（2）DENSE_RANK() </p>
<p>排序相同时会重复，总数会减少</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11223</span><br></pre></td></tr></table></figure>

<p>（3）ROW_NUMBER()</p>
<p>会根据顺序计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12345</span><br></pre></td></tr></table></figure>

<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>datediff：返回结束日期减去开始日期的天数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datediff(string enddate, string startdate) select datediff(&#x27;2021-11-20&#x27;,&#x27;2021-11-22&#x27;) </span><br></pre></td></tr></table></figure>

<p>date_add：返回开始日期startdate增加days天后的日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date_add(string startdate, int days) select date_add(&#x27;2021-11-20&#x27;,3) </span><br></pre></td></tr></table></figure>

<p>date_sub：返回开始日期startdate减少days天后的日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date_sub (string startdate, int days) select date_sub(&#x27;2021-11-22&#x27;,3)</span><br></pre></td></tr></table></figure>

<h2 id="Impala-时间处理，可类比到hive可用"><a href="#Impala-时间处理，可类比到hive可用" class="headerlink" title="Impala(时间处理，可类比到hive可用)"></a>Impala(时间处理，可类比到hive可用)</h2><h3 id="1-获取当前时间"><a href="#1-获取当前时间" class="headerlink" title="1. 获取当前时间"></a>1. 获取当前时间</h3><p>timestamp 样式2021-12-10 04:36:48.147046000</p>
<p>bigint 样式 1639110956</p>
<table>
<thead>
<tr>
<th>函数/方法</th>
<th>输出类型</th>
<th>说明/样式</th>
</tr>
</thead>
<tbody><tr>
<td>current_timestamp()</td>
<td>timestamp</td>
<td>所在时区的当前时间</td>
</tr>
<tr>
<td>now()</td>
<td>timestamp</td>
<td>所在时区的当前时间</td>
</tr>
<tr>
<td>unix_timestamp()</td>
<td>bigint</td>
<td>所在时区的当前时间戳</td>
</tr>
<tr>
<td>utc_timestamp</td>
<td>timestamp</td>
<td>UTC时区的当前时间</td>
</tr>
<tr>
<td>timeofday()</td>
<td>string</td>
<td>Fri Dec 10 12:39:46 2021 CST</td>
</tr>
</tbody></table>
<h3 id="2-获取时间指定单位函数"><a href="#2-获取时间指定单位函数" class="headerlink" title="2. 获取时间指定单位函数"></a>2. 获取时间指定单位函数</h3><table>
<thead>
<tr>
<th>序号</th>
<th>函数/方法</th>
<th>输出类型</th>
<th>说明/样式</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>year(timestamp/date)</td>
<td>int</td>
<td>获取年 yyyy</td>
</tr>
<tr>
<td>2</td>
<td>quarter(timestamp/date)</td>
<td>int</td>
<td>获取季节（1,2,3,4）</td>
</tr>
<tr>
<td>3</td>
<td>month(timestamp/date)</td>
<td>int</td>
<td>获取月</td>
</tr>
<tr>
<td>4</td>
<td>monthname(timestamp/date)</td>
<td>string</td>
<td>获取月份名称 December</td>
</tr>
<tr>
<td>5</td>
<td>week(timestamp/date)</td>
<td>int</td>
<td>获取周（1-53）</td>
</tr>
<tr>
<td>6</td>
<td>weekofyear(timestamp/date)</td>
<td>int</td>
<td>获取周（1-53）</td>
</tr>
<tr>
<td>7</td>
<td>dayofweek(timestamp/date)</td>
<td>int</td>
<td>获取天（本周第多少天,周日算第一天）</td>
</tr>
<tr>
<td>8</td>
<td>dayname(timestamp/date)</td>
<td>string</td>
<td>获取天（星期几）Friday</td>
</tr>
<tr>
<td>9</td>
<td>next_day(timestamp/date, 10</td>
<td>day(string))</td>
<td>timestamp/date</td>
</tr>
<tr>
<td>11</td>
<td>day(timestamp/date)</td>
<td>int</td>
<td>获取天（本月第多少天）</td>
</tr>
<tr>
<td>12</td>
<td>dayofmonth(timestamp/date)</td>
<td>int</td>
<td>获取天（本月第多少天）</td>
</tr>
<tr>
<td>13</td>
<td>last_day(timestamp/date)</td>
<td>timestamp/date</td>
<td>获取天（本月的最后一天日期）</td>
</tr>
<tr>
<td>14</td>
<td>dayofyear(timestamp/date)</td>
<td>int</td>
<td>获取天（本年第多少天）</td>
</tr>
<tr>
<td>15</td>
<td>hour(timestamp/date)</td>
<td>int</td>
<td>获取小时</td>
</tr>
<tr>
<td>16</td>
<td>minute(timestamp date)</td>
<td>int</td>
<td>获取分钟</td>
</tr>
<tr>
<td>17</td>
<td>second(timestamp date)</td>
<td>int</td>
<td>获取秒</td>
</tr>
<tr>
<td>18</td>
<td>millisecond(timestamp date)</td>
<td>int</td>
<td>获取毫秒</td>
</tr>
<tr>
<td>19</td>
<td>extract (YEAR FROM timestamp)</td>
<td>bigint</td>
<td>获取参数指定的时间单位 YEAR MONTH DAY  HOUR MINUTE SECOND</td>
</tr>
<tr>
<td>20</td>
<td>date_part(‘year’,timestamp)</td>
<td>bigint</td>
<td>获取参数指定的时间单位 YEAR MONTH DAY  HOUR MINUTE SECOND</td>
</tr>
<tr>
<td>21</td>
<td>trunc(timestamp/date,unit)</td>
<td>timestamp/date</td>
<td>获取截断为指定单位的时间</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>unit</th>
<th>截取说明</th>
</tr>
</thead>
<tbody><tr>
<td>SYYYY，YYYY，YEAR，SYEAR，YYY，YY，Y</td>
<td>年</td>
</tr>
<tr>
<td>Q</td>
<td>季节</td>
</tr>
<tr>
<td>MONTH，MON，MM，RM</td>
<td>月</td>
</tr>
<tr>
<td>WW</td>
<td>最近的日期是与一年中的第一天相同的日期</td>
</tr>
<tr>
<td>W</td>
<td>最近的日期是与该月的第一天相同的星期几</td>
</tr>
<tr>
<td>DDD，DD，J</td>
<td>天</td>
</tr>
<tr>
<td>DAY，DY，D</td>
<td>星期几（星期一）的开始</td>
</tr>
<tr>
<td>HH，HH12，HH24</td>
<td>小时</td>
</tr>
<tr>
<td>MI</td>
<td>分钟</td>
</tr>
</tbody></table>
<h3 id="3-时间比较函数"><a href="#3-时间比较函数" class="headerlink" title="3. 时间比较函数"></a>3. 时间比较函数</h3><table>
<thead>
<tr>
<th>序号</th>
<th>函数/方法</th>
<th>输出类型</th>
<th>说明/样式</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>datediff(timestamp enddate,startdate)</td>
<td>int</td>
<td>返回endDate比startDate多多少天</td>
</tr>
<tr>
<td>2</td>
<td>int_months_between(timestamp t1,t2)</td>
<td>int</td>
<td>返回两个日期相差的整数月份个数</td>
</tr>
<tr>
<td>3</td>
<td>months_between(timestamp t1,t2)</td>
<td>double</td>
<td>返回浮点数的月数相差的数</td>
</tr>
<tr>
<td>4</td>
<td>date_cmp(DATE date1, DATE date2)</td>
<td>int</td>
<td>比较是否相等，返回-1,0,1,null四种数值</td>
</tr>
<tr>
<td>5</td>
<td>timestamp_cmp(timestamp t1，timestamp t2)</td>
<td>int</td>
<td>比较是否相等，返回-1,0,1,null四种数值</td>
</tr>
</tbody></table>
<h3 id="4-时间格式转换函数"><a href="#4-时间格式转换函数" class="headerlink" title="4. 时间格式转换函数"></a>4. 时间格式转换函数</h3><table>
<thead>
<tr>
<th>序号</th>
<th>函数/方法</th>
<th>输出类型</th>
<th>说明/样式</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>to_date(timestamp date)</td>
<td>string</td>
<td>返回时间戳对应的date</td>
</tr>
<tr>
<td>2</td>
<td>to_timestamp(bigint unixtime)</td>
<td>timestamp</td>
<td>返回整数对应的timestamp值</td>
</tr>
<tr>
<td>3</td>
<td>to_timestamp(string date，string pattern)</td>
<td>timestamp</td>
<td>返回字符串对应的timestamp值</td>
</tr>
<tr>
<td>4</td>
<td>to_utc_timestamp(timestamp t，string timezone)</td>
<td>timestamp</td>
<td>指定时区的时间戳转化为UTC时区的时间戳</td>
</tr>
<tr>
<td>5</td>
<td>from_timestamp(timestamp t，string pattern)</td>
<td>string</td>
<td>把timestamp按照pattern进行格式化</td>
</tr>
<tr>
<td>6</td>
<td>from_timestamp(string date，string pattern)</td>
<td>string</td>
<td>把date按照pattern进行格式化</td>
</tr>
<tr>
<td>7</td>
<td>from_unixtime(bigint unixtime)</td>
<td>string</td>
<td>把时间戳秒数转化为本地地区中的字符串</td>
</tr>
<tr>
<td>8</td>
<td>from_unixtime(bigint unixtime，string pattern）</td>
<td>string</td>
<td>时间戳转化为本地时区字符串，pattern格式</td>
</tr>
<tr>
<td>9</td>
<td>from_utc_timestamp（timestamp t，string timezone）</td>
<td>timestamp</td>
<td>UTC时区指定时间戳转化为指定时区时间戳</td>
</tr>
<tr>
<td>10</td>
<td>unix_timestamp(string datetime)</td>
<td>bigint</td>
<td>把string类型的date或日期转化成时间戳Unix</td>
</tr>
<tr>
<td>11</td>
<td>unix_timestamp(timestamp datetime)</td>
<td>bigint</td>
<td>把string类型的timestamp转化成时间戳Unix</td>
</tr>
<tr>
<td>12</td>
<td>unix_timestamp(string datetime，string pattern)</td>
<td>bigint</td>
<td>日期按pattern转化成时间戳Unix</td>
</tr>
</tbody></table>
<h3 id="5-时间计算函数"><a href="#5-时间计算函数" class="headerlink" title="5. 时间计算函数"></a>5. 时间计算函数</h3><table>
<thead>
<tr>
<th>序号</th>
<th>函数/方法</th>
<th>输出类型</th>
<th>说明/样式</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>years_add(timestamp/date date, int/bigint years)</td>
<td>timestamp/date</td>
<td>增加指定年数</td>
</tr>
<tr>
<td>2</td>
<td>years_sub(timestamp/date date, int/bigint years)</td>
<td>timestamp/date</td>
<td>减少指定年数</td>
</tr>
<tr>
<td>3</td>
<td>months_add(timestamp/date date, int/bigint months)</td>
<td>timestamp/date</td>
<td>增加指定月数</td>
</tr>
<tr>
<td>4</td>
<td>months_sub(timestamp/date date, int/bigint months)</td>
<td>timestamp/date</td>
<td>减少指定月数</td>
</tr>
<tr>
<td>5</td>
<td>add_months(timestamp/date date, int/bigint months)</td>
<td>timestamp/date</td>
<td>增加指定月数</td>
</tr>
<tr>
<td>6</td>
<td>weeks_add(timestamp/date date, int/bigint weeks)</td>
<td>timestamp/date</td>
<td>增加指定周数</td>
</tr>
<tr>
<td>7</td>
<td>weeks_sub(timestamp/date date, int/bigint weeks)</td>
<td>timestamp/date</td>
<td>减少指定周数</td>
</tr>
<tr>
<td>8</td>
<td>days_add(timestamp/date startdate, int/bigint days)</td>
<td>timestamp/date</td>
<td>增加指定天数</td>
</tr>
<tr>
<td>9</td>
<td>days_sub(timestamp/date startdate, int/bigint days)</td>
<td>timestamp/date</td>
<td>减少指定天数</td>
</tr>
<tr>
<td>10</td>
<td>date_add(timestamp/date startdate, int/bigint days)</td>
<td>timestamp/date</td>
<td>增加指定天数</td>
</tr>
<tr>
<td>11</td>
<td>date_sub(timestamp/date startdate, int/bigint days)</td>
<td>timestamp/date</td>
<td>减少指定天数</td>
</tr>
<tr>
<td>12</td>
<td>adddate(timestamp/date startdate, int/int days)</td>
<td>timestamp/date</td>
<td>增加指定天数</td>
</tr>
<tr>
<td>13</td>
<td>subdate(timestamp/date startdate，bigint/int days)</td>
<td>timestamp/date</td>
<td>减少指定天数</td>
</tr>
<tr>
<td>14</td>
<td>hours_add(timestamp date, int/bigint hours)</td>
<td>timestamp</td>
<td>增加指定小时</td>
</tr>
<tr>
<td>15</td>
<td>hours_sub(timestamp date, int/bigint hours)</td>
<td>timestamp</td>
<td>减少指定小时</td>
</tr>
<tr>
<td>16</td>
<td>minutes_add(timestamp date, int/bigint minutes)</td>
<td>timestamp</td>
<td>增加指定分钟</td>
</tr>
<tr>
<td>17</td>
<td>minutes_sub(timestamp date, int/bigint minutes)</td>
<td>timestamp</td>
<td>减少指定分钟</td>
</tr>
<tr>
<td>18</td>
<td>seconds_add(timestamp date, int/bigint seconds)</td>
<td>timestamp</td>
<td>增加指定秒数</td>
</tr>
<tr>
<td>19</td>
<td>seconds_sub(timestamp date, int/bigint seconds)</td>
<td>timestamp</td>
<td>减少指定秒数</td>
</tr>
<tr>
<td>20</td>
<td>milliseconds_add(timestamp t, int/bigint s）</td>
<td>timestamp</td>
<td>增加指定毫秒数</td>
</tr>
<tr>
<td>21</td>
<td>milliseconds_sub(timestamp t, int/bigint s）</td>
<td>timestamp</td>
<td>减少指定毫秒数</td>
</tr>
<tr>
<td>22</td>
<td>microseconds_add(timestamp t, int/bigint s)</td>
<td>timestamp</td>
<td>增加指定微秒数</td>
</tr>
<tr>
<td>23</td>
<td>microseconds_sub(timestamp t, int/bigint s)</td>
<td>timestamp</td>
<td>减少指定微秒数</td>
</tr>
<tr>
<td>24</td>
<td>nanoseconds_add(timestamp t, int/bigint s）</td>
<td>timestamp</td>
<td>增加指定纳秒数</td>
</tr>
<tr>
<td>25</td>
<td>nanoseconds_sub(timestamp t, int/bigint s）</td>
<td>timestamp</td>
<td>减少指定纳秒数</td>
</tr>
<tr>
<td>26</td>
<td>date_add(timestamp/date startdate, interval_expression)</td>
<td>timestamp/date</td>
<td>使用参数计算日期增量值（增加）</td>
</tr>
<tr>
<td>27</td>
<td>date_sub(timestamp/date startdate, interval_expression)</td>
<td>timestamp/date</td>
<td>使用参数计算日期增量值（减少）</td>
</tr>
</tbody></table>
<hr>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h3><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>keys  *</td>
<td>查看当前库的所有键</td>
</tr>
<tr>
<td>exists <key></td>
<td>判断某个键是否存在</td>
</tr>
<tr>
<td>type <key></td>
<td>查看键的类型</td>
</tr>
<tr>
<td>del <key></td>
<td>删除某个键</td>
</tr>
<tr>
<td>expire <key> <seconds></td>
<td>为键值设置过期时间，单位秒</td>
</tr>
<tr>
<td>ttl <key></td>
<td>查看还有多久过期,-1表示永不过期,-2表示已过期</td>
</tr>
<tr>
<td>dbsize</td>
<td>查看当前数据库中key的数量</td>
</tr>
<tr>
<td>flushdb</td>
<td>清空当前库</td>
</tr>
<tr>
<td>Flushall</td>
<td>通杀全部库</td>
</tr>
</tbody></table>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>get <key></td>
<td>查询对应键值</td>
</tr>
<tr>
<td>set <key> <value></td>
<td>添加键值对</td>
</tr>
<tr>
<td>append <key> <value></td>
<td>将给定的<value>追加到原值的末尾</td>
</tr>
<tr>
<td>strlen <key></td>
<td>获取值的长度</td>
</tr>
<tr>
<td>setnx <key> <value></td>
<td>只有在key 不存在时设置key的值</td>
</tr>
<tr>
<td>incr <key></td>
<td>将key中存储的数字值增1只能对数字值操作，如果为空，新增值为1</td>
</tr>
<tr>
<td>decr <key></td>
<td>将key中存储的数字值减1只能对数字之操作，如果为空,新增值为-1</td>
</tr>
<tr>
<td>incrby /decrby <key> 步长</td>
<td>将key中存储的数字值增减，自定义步长</td>
</tr>
<tr>
<td>mset <key1> <value1> <key2> <value2></td>
<td>同时设置一个或多个key-value对</td>
</tr>
<tr>
<td>mget <key1> <key2>  <key3></td>
<td>同时获取一个或多个value</td>
</tr>
<tr>
<td>msetnx <key1> <value1> <key2> <value2></td>
<td>同时设置一个或多个key-value对，当且仅当所有给定的key都不存在</td>
</tr>
<tr>
<td>getrange <key> &lt;起始位置&gt; &lt;结束位置&gt;</td>
<td>获得值的范围,类似java中的substring</td>
</tr>
<tr>
<td>setrange <key> &lt;起始位置&gt; <value></td>
<td>用<value>覆盖<key>所存储的字符串值，从&lt;起始位置&gt;开始</td>
</tr>
<tr>
<td>setex <key> &lt;过期时间&gt; <value></td>
<td>设置键值的同时，设置过去时间，单位秒</td>
</tr>
<tr>
<td>getset <key> <value></td>
<td>以新换旧,设置了新值的同时获取旧值</td>
</tr>
</tbody></table>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>lpush/rpush  <key>  <value1>  <value2></td>
<td>从左边/右边插入一个或多个值。</td>
</tr>
<tr>
<td>lpop/rpop  <key></td>
<td>从左边/右边吐出一个值。值在键在，值光键亡。</td>
</tr>
<tr>
<td>rpoplpush  <key1>  <key2></td>
<td>从<key1>列表右边吐出一个值，插到<key2>列表左边</td>
</tr>
<tr>
<td>lrange <key> <start> <stop></td>
<td>按照索引下标获得元素(从左到右)</td>
</tr>
<tr>
<td>lindex <key> <index></td>
<td>按照索引下标获得元素(从左到右)</td>
</tr>
<tr>
<td>llen <key></td>
<td>获得列表长度</td>
</tr>
<tr>
<td>linsert <key>  before <value>  <newvalue></td>
<td>在<value>的后面插入<newvalue> 插入值</td>
</tr>
<tr>
<td>lrem <key> <n>  <value></td>
<td>从左边删除n个value(从左到右)</td>
</tr>
</tbody></table>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>sadd <key>  <value1>  <value2> ….</td>
<td>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</td>
</tr>
<tr>
<td>smembers <key></td>
<td>取出该集合的所有值。</td>
</tr>
<tr>
<td>sismember <key>  <value></td>
<td>判断集合<key>是否为含有该<value>值，有返回1，没有返回0</td>
</tr>
<tr>
<td>scard  <key></td>
<td>返回该集合的元素个数。</td>
</tr>
<tr>
<td>srem <key> <value1> <value2> ….</td>
<td>删除集合中的某个元素。</td>
</tr>
<tr>
<td>spop <key></td>
<td>随机从该集合中吐出一个值。</td>
</tr>
<tr>
<td>srandmember <key> <n></td>
<td>随机从该集合中取出n个值。不会从集合中删除</td>
</tr>
<tr>
<td>sinter <key1> <key2></td>
<td>返回两个集合的交集元素。</td>
</tr>
<tr>
<td>sunion <key1> <key2></td>
<td>返回两个集合的并集元素。</td>
</tr>
<tr>
<td>sdiff <key1> <key2></td>
<td>返回两个集合的差集元素。</td>
</tr>
</tbody></table>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>hset <key>  <field>  <value></td>
<td>给<key>集合中的  <field>键赋值<value></td>
</tr>
<tr>
<td>hget <key1>  <field></td>
<td>从<key1>集合<field> 取出 value</td>
</tr>
<tr>
<td>hmset <key1>  <field1> <value1> <field2> <value2>…</td>
<td>批量设置hash的值</td>
</tr>
<tr>
<td>hexists key  <field></td>
<td>查看哈希表 key 中，给定域 field 是否存在。</td>
</tr>
<tr>
<td>hkeys <key></td>
<td>列出该hash集合的所有field</td>
</tr>
<tr>
<td>hvals <key></td>
<td>列出该hash集合的所有value</td>
</tr>
<tr>
<td>hincrby <key> <field>  <increment></td>
<td>为哈希表 key 中的域 field 的值加上增量 increment</td>
</tr>
<tr>
<td>hsetnx <key>  <field> <value></td>
<td>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</td>
</tr>
</tbody></table>
<h3 id="zset-Sorted-set"><a href="#zset-Sorted-set" class="headerlink" title="zset(Sorted set)"></a>zset(Sorted set)</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>zadd  <key> <score1> <value1>  <score2> <value2>…</td>
<td>将一个或多个 member 元素及其 score 值加入到有序集 key 当中</td>
</tr>
<tr>
<td>zrange <key>  <start> <stop>  [WITHSCORES]</td>
<td>返回有序集 key 中，下标在<start> <stop>之间的元素带WITHSCORES，可以让分数一起和值返回到结果集。</td>
</tr>
<tr>
<td>zrangebyscore key min max [withscores] [limit offset count]</td>
<td>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</td>
</tr>
<tr>
<td>zrevrangebyscore key max min [withscores] [limit offset count]</td>
<td>同上，改为从大到小排列。</td>
</tr>
<tr>
<td>zincrby <key> <increment> <value></td>
<td>为元素的score加上增量</td>
</tr>
<tr>
<td>zrem  <key>  <value></td>
<td>删除该集合下，指定值的元素</td>
</tr>
<tr>
<td>zcount <key>  <min>  <max></td>
<td>统计该集合，分数区间内的元素个数</td>
</tr>
<tr>
<td>zrank <key>  <value></td>
<td>返回该值在集合中的排名，从0开始。</td>
</tr>
</tbody></table>
<hr>
<h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./start-cluster.sh </span><br></pre></td></tr></table></figure>

<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/flink run [OPTIONS]./bin/flink run -m yarn-cluster -c com.wang.flink.WordCount /opt/app/WordCount.jar</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>OPTIONS</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>detached 是否使用分离模式</td>
</tr>
<tr>
<td>-m</td>
<td>jobmanager 指定提交的jobmanager</td>
</tr>
<tr>
<td>-yat</td>
<td>–yarnapplicationType 设置yarn应用的类型</td>
</tr>
<tr>
<td>-yD</td>
<td>使用给定属性的值</td>
</tr>
<tr>
<td>-yd</td>
<td>–yarndetached 使用yarn分离模式</td>
</tr>
<tr>
<td>-yh</td>
<td>–yarnhelp yarn session的帮助</td>
</tr>
<tr>
<td>-yid</td>
<td>–yarnapplicationId 挂到正在运行的yarnsession上</td>
</tr>
<tr>
<td>-yj</td>
<td>–yarnjar Flink jar文件的路径</td>
</tr>
<tr>
<td>-yjm</td>
<td>–yarnjobManagerMemory jobmanager的内存(单位M)</td>
</tr>
<tr>
<td>-ynl</td>
<td>–yarnnodeLabel 指定 YARN 应用程序 YARN 节点标签</td>
</tr>
<tr>
<td>-ynm</td>
<td>–yarnname 自定义yarn应用名称</td>
</tr>
<tr>
<td>-yq</td>
<td>–yarnquery 显示yarn的可用资源</td>
</tr>
<tr>
<td>-yqu</td>
<td>–yarnqueue 指定yarn队列</td>
</tr>
<tr>
<td>-ys</td>
<td>–yarnslots 指定每个taskmanager的slots数</td>
</tr>
<tr>
<td>-yt</td>
<td>yarnship 在指定目录中传输文件</td>
</tr>
<tr>
<td>-ytm</td>
<td>–yarntaskManagerMemory 每个taskmanager的内存</td>
</tr>
<tr>
<td>-yz</td>
<td>–yarnzookeeperNamespace 用来创建ha的zk子路径的命名空间</td>
</tr>
<tr>
<td>-z</td>
<td>–zookeeperNamespace 用来创建ha的zk子路径的命名空间</td>
</tr>
<tr>
<td>-p</td>
<td>并行度</td>
</tr>
<tr>
<td>-yn</td>
<td>需要分配的YARN容器个数(=任务管理器的数量)</td>
</tr>
</tbody></table>
<h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/flink info [OPTIONS]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>OPTIONS</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>程序进入点，主类</td>
</tr>
<tr>
<td>-p</td>
<td>并行度</td>
</tr>
</tbody></table>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/flink list [OPTIONS]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>OPTIONS</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>–all 显示所有应用和对应的job id</td>
</tr>
<tr>
<td>-r</td>
<td>–running 显示正在运行的应用和job id</td>
</tr>
<tr>
<td>-s</td>
<td>–scheduled 显示调度的应用和job id</td>
</tr>
<tr>
<td>-m</td>
<td>–jobmanager 指定连接的jobmanager</td>
</tr>
<tr>
<td>-yid</td>
<td>–yarnapplicationId 挂到指定的yarn id对应的yarn session上</td>
</tr>
<tr>
<td>-z</td>
<td>–zookeeperNamespace 用来创建ha的zk子路径的命名空间</td>
</tr>
</tbody></table>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/flink stop  [OPTIONS] &lt;Job ID&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>OPTIONS</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>在采取保存点和停止管道之前，发送MAX_WATERMARK</td>
</tr>
<tr>
<td>-p</td>
<td>savepointPath 保存点的路径 ‘xxxxx’</td>
</tr>
<tr>
<td>-m</td>
<td>–jobmanager 指定连接的jobmanager</td>
</tr>
<tr>
<td>-yid</td>
<td>–yarnapplicationId 挂到指定的yarn id对应的yarn session上</td>
</tr>
<tr>
<td>-z</td>
<td>–zookeeperNamespace 用来创建ha的zk子路径的命名空间</td>
</tr>
</tbody></table>
<h3 id="cancel-弱化"><a href="#cancel-弱化" class="headerlink" title="cancel(弱化)"></a>cancel(弱化)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/flink cancel  [OPTIONS] &lt;Job ID&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>OPTIONS</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>-s</td>
<td>使用 “stop “代替</td>
</tr>
<tr>
<td>-D</td>
<td>允许指定多个通用配置选项</td>
</tr>
<tr>
<td>-m</td>
<td>要连接的JobManager的地址</td>
</tr>
<tr>
<td>-yid</td>
<td>–yarnapplicationId 挂到指定的yarn id对应的yarn session上</td>
</tr>
<tr>
<td>-z</td>
<td>–zookeeperNamespace 用来创建ha的zk子路径的命名空间</td>
</tr>
</tbody></table>
<h3 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a>savepoint</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/flink savepoint  [OPTIONS] &lt;Job ID&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>OPTIONS</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>要处理的保存点的路径</td>
</tr>
<tr>
<td>-j</td>
<td>Flink程序的JAR文件</td>
</tr>
<tr>
<td>-m</td>
<td>要连接的JobManager的地址</td>
</tr>
<tr>
<td>-yid</td>
<td>–yarnapplicationId 挂到指定的yarn id对应的yarn session上</td>
</tr>
<tr>
<td>-z</td>
<td>–zookeeperNamespace 用来创建ha的zk子路径的命名空间</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>BigData</category>
        <category>大数据常用命令</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>知识碎片</title>
    <url>/2021/12/23/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/</url>
    <content><![CDATA[<p>1、在写sparkstreaming代码出现暴内存不足的情况？</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;InitData&quot;</span>)</span><br><span class="line">      .setMaster(<span class="string">&quot;local[*]&quot;</span>).set(<span class="string">&quot;spark.testing.memory&quot;</span>,<span class="string">&quot;471859200&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2、代码中出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: org/apache/spark/sql/SparkSession</span><br><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">原因：</span><br><span class="line">	pom文件中的依赖中scope填写的是provided，这是用于打包的时候防止需要的依赖一起打包导致包太大，但需要在服务器中已经有这些依赖了，否则加上这个在服务其中报没有依赖的错误，idea默认是compile，</span><br><span class="line">解决：</span><br><span class="line">	注释掉该标签</span><br></pre></td></tr></table></figure>

<p>3、通过idea代码读取hdfs数据时，可能会出现lzo压缩找不到，所以需要在core-site.xml文件中添加配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span><span class="comment">&lt;!--这个配置可以不要--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>io.compression.codecs<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">           org.apache.hadoop.io.compress.GzipCodec,</span><br><span class="line">           org.apache.hadoop.io.compress.DefaultCodec,</span><br><span class="line">           org.apache.hadoop.io.compress.BZip2Codec,</span><br><span class="line">           org.apache.hadoop.io.compress.SnappyCodec</span><br><span class="line">           <span class="comment">&lt;!--com.hadoop.compression.lzo.LzoCodec,这里不能打开，否则报lzo找不到--&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--com.hadoop.compression.lzo.LzopCodec这里不能打开，否则报lzo找不到--&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>io.compression.codec.lzo.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.hadoop.compression.lzo.LzoCodec<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、spark中task并发和并行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三台节点，一个2核，总共6核，</span><br><span class="line">并发度理解为同时执行的task数量。这里并发度为6；</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>碎片</category>
        <category>知识碎片</category>
      </categories>
      <tags>
        <tag>知识碎片</tag>
      </tags>
  </entry>
</search>
